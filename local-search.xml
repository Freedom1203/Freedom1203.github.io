<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Android逆向基础学习</title>
    <link href="/2023/08/31/Android%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/08/31/Android%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Android逆向基础学习"><a href="#Android逆向基础学习" class="headerlink" title="Android逆向基础学习"></a>Android逆向基础学习</h1><h2 id="Android开发"><a href="#Android开发" class="headerlink" title="Android开发"></a>Android开发</h2><h3 id="1、安卓系统平台架构及特性"><a href="#1、安卓系统平台架构及特性" class="headerlink" title="1、安卓系统平台架构及特性"></a>1、安卓系统平台架构及特性</h3><p> <strong>简介</strong> </p><p>Android 系统的底层建立在Linux 系统之上， 该平台由操作系统、中间件、用户界面和应用软件组成，它采用一种被称为软件叠层（Software  Stack）的方式进行构建。这种软件叠层结构使得层与层之间相互分离，明确各层的分工。 这种分工保证了层与层之间的低耦合，当下层的层内或者层下发生变化时，上层应用程序无需任何改变。</p><p>Android系统的体系结构图</p><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1442084/1654141541178-cdb9156d-2587-498c-b196-c2c63324ec1c.jpeg?x-oss-process=image/resize,w_750,limit_0/interlace,1" alt="img"></p><p><strong>系统APP层</strong></p><p>Android  系统将会包含一些列核心APP（应用程序）， 包括电话拨号应用、电子邮件客户端、日历、相机、联系人等。这些应用程序通常都是有java编写的。普通开发者开发的各种App， 都位于这一层。</p><p><strong>java API框架层</strong></p><p>开发Android App就是面向Java API框架进行开发。 Android 系统上的各种App是完全平等的，不管是Android 系统本身提供的App，还是普通开发者所开发的App， 都可以调用Android 提供的Java API框架。</p><p>Java API 除了作为APP 开发的基础外， 任何一个应用程序都可以发布它的功能模块—— 只要发布时遵守了API 框架的规范，其他APP就可以调用这个模块。</p><p><strong>原生C&#x2F;C++库</strong></p><p>Android 包含一套被不同组件所使用的 C&#x2F; C++库的集合。 Android 应用开发者不能直接调用这套 C&#x2F;C++库， 而是应该通过它上面的Java API框架来调用这些库。</p><p>下面列出一些原生的 C&#x2F;C++ 库：</p><p>●WebKit:一个全新的Web浏览器引擎，该引擎为Android浏览器提供支持，也为WebView提供支持，WebView完全可以嵌入开发者自己的应用程序中。</p><p>●OpenMAX(开放媒体加速层):其目的在于使用统一的接口，加速处理大量多媒体资料。其中最上层为OpenMAX AL(App Layer)，该层代表App和多媒体中间层的标准接口使得App在多媒体接口上具有良好的可移植性。</p><p>●Libc(系统C库):一个从BSD系统派生的标准C系统库，并且专门为嵌入式Linux设备调整过。</p><p>● Media Framework(媒体框架):基于PacketVideo的OpenCORE，这套媒体库支持播放和录制许多流行的音频和视频格式，以及查看静态图片。它主要包括MPEG4、H.264、MP3、AAC、AMR、JPG、PNG等多媒体格式。</p><p>●SGL:底层的2D图形引擎。</p><p>●OpenGLES:基于OpenGLES API实现的3D系统，这套3D库既可使用硬件3D加速(如果硬件系统支持的话)，也可使用高度优化的软件3D加速。</p><p>●SQLite:供所有应用程序使用的功能强大的轻量级关系数据库。</p><p><strong>Android  运行时</strong></p><p>Android  运行时由两部分组成： Android 核心库 和 ART。其中核心库提供了Java 语言核心所能使用的绝大部分功能； 而ART 则负责运行Android 应用程序。</p><p>早期Android运行时由Dalvik虚拟机和Android核心库集组成，但由于Dalvik虚拟机采用了</p><p>一种被称为JIT(Just-In-Time)的解释器进行动态编译并执行，因此导致Android App运行时比较</p><p>慢。从Android 5.0开始，Android运行时改为使用ART，ART在用户安装App时进行预编译</p><p>(Ahead-Of-Time,AOT)，将原本在程序运行时的编译动作提前到App安装时，这样使得程序在运</p><p>行时可以减少动态编译的开销，从而提升Android App的运行效率。</p><p>反过来，由于ART需要在安装App时进行AOT处理，因此ART需要占用更多的存储空间，</p><p>应用安装和系统启动时间会延长不少。此外，ART还支持ARM、x86和MIPS架构，并且能完全</p><p>兼容64位系统。</p><p>Android 6.0的重要更新是运行时权限，使得App能在安装之后动态地请求获取相关权限;</p><p>Android 7.0的重要更新则是多窗口模式。</p><p><strong>硬件抽象层（HAL）</strong></p><p>硬件抽象层主要提供可对Linux 内核驱动的封装， 这种封装可以向上提供音频、蓝牙、摄像头、传感提等设备的编程接口，向下则可隐藏底层的实现细节。</p><p>简单来说， Android 系统把对硬件的支持分为两层： 内核驱动层和硬件抽象层。其中底层的内</p><p>核驱动层处于Linux内核中，内核驱动层只提供简单的硬件访问逻辑，这部分代码是完全开源的;  而硬件抽象层则负责参数和访问流程控制，这层的封装代码并不开源，它只是向上提供统一的编程接口，而具体的实现往往属于各厂家。</p><p><strong>Linux内核</strong></p><p>Android 系统是基于 Linux 的（Android 本质上就是一个Linux 系统）。Linux 提供了安全性、内存管理、进程管理、网络协议栈和驱动模型等核心系统服务。 除此之外，Linux 内核也是系统硬件和软件叠层之间的抽象层。</p><h3 id="2、APP安全基础"><a href="#2、APP安全基础" class="headerlink" title="2、APP安全基础"></a>2、APP安全基础</h3><p><strong>1. Android App的安全基础</strong></p><p><strong>（1）APP 代码编写</strong></p><p>Android  App 主要采用Java 编程语言编写， 包括Activity、Service、Broadcast Receiver 、 Content Provider 四大组件。Android  App 的编译过程与一般的 Java App 不同，但开始方式是一样的：使用 Javac 命令将 Java源代码文件编译成class 文件，如下所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1442084/1642241659953-8967e906-6fad-4501-b237-578d5b41a7f6.png" alt="img"></p><p>例如，创建一个测试程序 Test.java ，在cmd 环境下使用 Javac Test.java 命令将下面的Test.java  源代码生成Test.class 文件（ 该文件属于标准的Oracle Jvm Java字节码）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">public class Test&#123;<br>public int add(int a ,int b)&#123;<br>return a + b;<br>&#125;<br><br>public static void main(String[] args) &#123;<br>Test test = new Test();<br>System.out.printf(test.add(1,2));<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1442084/1642242090186-67c52993-1fa4-4554-9257-7b5a50b9603f.png" alt="img"></p><p>然后使用javap -c Test.class 命令查看上面的Java代码对应的Java 字节码，示例如下</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1442084/1642242552897-84189365-5bb9-45e2-9e0d-9e2e93884aa9.png" alt="img"></p><p><strong>（2） 转成 Dalvik 格式（dex文件）</strong></p><p>但是，Android 系统APP 并没有使用标准的Java 虚拟机来运行， 而是通过自带的 Dalvik 虚拟机来运行。 与 Java虚拟机的字节码不同，  Dalvik  虚拟机有自己独特的字节码格式，即两个虚拟机的机器指令集不同， 因此 ， 通过 javac 编译生成的 class 文件无法在 Dalvik 虚拟机上运行。</p><p>开发者需要使用Android  系统的 dx 命令（位于 \sdk\build-tools\路径下）， 将 class 文件和所有的jar包转成符合 Dalvik 字节码格式的 classes .dex 文件。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1442084/1642254369561-a06b50b3-89da-4d37-b483-1e5ee3b6f4fe.png" alt="img"></p><p>在这里我采用降低jdk版本的方式,  不然的话会报错，版本不支持</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">javac -source 1.6 -target 1.6 first.java<br></code></pre></td></tr></table></figure><p>然后使用dx  命令把生成的class文件编译成classes.dex 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">dx --dex --output=classes.dex  Test.class<br></code></pre></td></tr></table></figure><p>注意： –dex 这是双横线， 需要把 class 文件放在dx 的目录下</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1442084/1642325780927-6e29e050-9056-4190-a163-98ccbeb8aa9b.png" alt="img"></p><p>使用 jadx-gui 打开dex文件， classes.dex 对应的 Dalvik字节码形式如下</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1442084/1642325851106-9a190b42-5572-4eae-9144-ed21b8d2cf70.png" alt="img"></p><p><strong>（3）APP打包</strong></p><p>classes.dex 文件可以理解为 Android APP的可执行文件，核心的代码都在这个文件中。不过classes.dex 文件并不是安装文件， 为了便于安装，Android 将APP打包成类似于 Zip压缩文件的 APK文件。</p><p>一个APK文件并不仅包含APP的所有代码，而且还包含所有的非代码资源，如图片、声音等等。 使用 Android  SDK 中的打包工具或者 Android 系统的 aapt 命令， 能够将 classes.dex 文件和 APP 涉及的资源（如图片文件和 布局描述文件等）打包成 APK 文件（即安装包）。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1442084/1642327352288-ecc20ce1-6d65-4e36-ba3a-7f9b7a0d0fdf.png" alt="img"></p><p><strong>（4）APP的签名</strong></p><p>再通过Google Play 或者第三方应用商店发布APP安装文件之前， Android 系统要求开发者对APP文件进行数字签名： 一面对APP 负责， 实现APP的可溯源；另一方面，便于操作系统在安装时利用数字签名效验文件的完整性和准确性，实现APP的防篡改。</p><p>对于APP包进行签名的过程是，使用开发者的私钥对 APK 安装包中的所有文件进行效验，并将生成的效验信息作为一个附加的签名文件内置于 APK 安装包中。</p><p>jarsigner 是 Java 开发工具包中常用的签名工具， 专门为 jar 包进行签名而创建，也可以用于对 APK 文件进行签名。  Android 系统中压缩文件的字节是对齐的， 可以在不解压文件的情况下读取文件的内容， 所以在APK签名之后， 开发者需要使用压缩文件对齐工具 zipalign 进行出力，保证 APK 文件的压缩部分在字节边界上是对齐的。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1442084/1642328462256-ed9a6d87-8069-42cf-a65a-cdbe9a6a5155.png" alt="img"></p><h3 id="3、-Android-APP的运行"><a href="#3、-Android-APP的运行" class="headerlink" title="3、 Android APP的运行"></a>3、 Android APP的运行</h3><p>（1）简单介绍 </p><p>从Android  4.4 版本开始 ， 谷歌公司在原有以 Dalvik 虚拟机方式运行APP的基础上，新增了 ART (Android Runtime）模式。在 Dalvik 虚拟机运行时模式下，APP 每次运行都需要通过即时编译器将dex 文件字节码转换成机器码，即APP的每次运行都是转换加运行，虽然这会加快安装过程，但是会拖慢每次启动运行的效率。 </p><p>而在 ART 模式下，APP 在第一次安装的时候， 就会进行预编译， 将字节码编译成机器码。 这么做虽然会使设备和APP的安装和首次启动比较慢，但在此后的每次启动运行，APP都省去了机器码转换的工作，提高了运行效率。</p><p>Java 虚拟机的流程</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1442084/1642334514746-3ef1975d-1190-4524-b2fc-1c3b716e152d.png" alt="image.png"></p><p>Dalvik 虚拟机运行流程</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1442084/1642334953015-0ec0ba5c-1059-4dbf-acb0-ad546c306c48.png" alt="image.png"></p><p>ART 模式</p><p>Java 源代码Java 字节编码Javacjava.class Java 字节编码dxARTJava 字节编码ART 运行环境dex2.oat.oat</p><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1442084/1642335389182-2a233bf7-96f4-472c-9f48-53b99594b2da.jpeg" alt="img"></p><p>下面主要学习下 ART 模式下运行的一般过程：</p><p>在Android 系统中， 有一个 名为 Zygote的进程用来孵化和启动其他APP， 这也是Android 运行的第一个 Dalvik 虚拟机进程。 但 Zygote 进程其实是一个不完整的 Android 程序进程， 虽然它的内存空间包含了 APP需要的所有核心库文件， 但它并不具备特定APP的代码。</p><p>Zygote 进程通过调用系统 fork() 函数来 快速的创建自身副本进程。 Android 系统是基于 Linux 内核的， 通过 fork 调用可以在短时间内复制生成一个这样的Zygote 副本进程， 如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1442084/1642336351688-b59917c6-842b-44a7-b7bd-4ec76d2157df.png" alt="image.png"></p><p>之所以通过 Zygote 进程复制新的进程， 是因为复制像Zygote 这样的半启动进程比从主系统文件中加载新进程快得多， 也就是说，通过Zygote 进程复制可以使APP的启动速度更快。</p><p>新的APP 进程在生成之后， 就需要加载属于本APP的程序代码， 这些程序代码就储存在 APK   文件包中的  classes.dex文件中。  在 ART 模式下， Android 系统使用 dex2oat 命令将 classes.dex 文件中字节码转换为本地 oat 格式文件，如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1442084/1642337233529-ec6c09a8-5be0-4552-bb44-f752331ad6f9.png" alt="image.png"></p><p>oat 格式文件是一种Android 系统自带的 elf 文件格式， 它不仅包含 classes.dex文件内容， 而且还包含由 classes.dex 文件转换的机器指令。 因此系统在APP 每次运行时重新转换原有 classes.dex 文件中的机器指令，就可以使用oat 已经转换好的机器指令在ART 模式下直接运行APP。</p><p>转换后的 oat 文件存储在操作系统的 &#x2F;data&#x2F;dalvik-cache 目录下， 形式如下所示</p><p>&#x2F;data&#x2F;dalvik-cache&#x2F;arm&#x2F;<a href="mailto:&#100;&#97;&#x74;&#97;&#x40;&#99;&#111;&#x6d;&#46;&#x64;&#101;&#109;&#x6f;&#46;&#116;&#101;&#x73;&#116;&#46;&#97;&#112;&#x6b;">&#100;&#97;&#x74;&#97;&#x40;&#99;&#111;&#x6d;&#46;&#x64;&#101;&#109;&#x6f;&#46;&#116;&#101;&#x73;&#116;&#46;&#97;&#112;&#x6b;</a>@classes.dex</p><p>该文件目录包含APP的包名， 以确保不会覆盖任何其他的APP。 oat 文件中转换后的机器代码是与 Android 设备的 CPU架构相关的。</p><p>系统将 oat 文件和相关库文件加载到内存中，并且直接映射到APP进程的内存区域， APP 的初始化从这里开始。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1442084/1642340134310-9956cbf4-9951-4dd4-99cc-f160555e1727.png" alt="image.png"></p><h3 id="4、-Android-系统的安全模型"><a href="#4、-Android-系统的安全模型" class="headerlink" title="4、 Android 系统的安全模型"></a>4、 Android 系统的安全模型</h3><p> <strong>0x01  简介：</strong> </p><p>Linux 是一个多用户操作系统，主要安全目标是使不同的用户相互隔离， 例如不同用户创建的文件相互无法访问，不同用户创建的程序不会相互的耗尽内存或CPU资源。 Android 系统虽然基于 Liunx 内核，但是并不像 LInux 系统那样多用户，而是将Linux 用户管理机制用到了 APP的沙箱设计中， 用于隔离不同的APP。 除少数特例除外， 每个APP 都在各自的沙箱中运行。 因此， Android 系统有效隔离了不同的APP 以及APP 与操作系统的其他部分， 这也成为了 Android 系统的基本安全模型。</p><p>在这个基础上，Android 系统又在设计时考虑了多方面的安全因素来保障系统的安全性，尤其是在 Android  4.3 版本之后， 实现了 SElinux（Security-Enhanced-Linux）安全机制，形成了 SE Android 系统。</p><p> <strong>0x02  Android 用户管理</strong> </p><p>一般来说， 在Linux 系统中， 可以注册多个物理用户， 每个用户都会分配一个特定的UID， 不同的用户均可以登录系统、安装APP、存储和读取文件、执行shell命令、开启后台系统服务进程等操作， 且互不影响。</p><p>Android 虽然继承了Linux 系统的多用户隔离特性，但是这种特性与一般的 Linux 系统不同。 因为Android  是私人设备，一个手机不会被多人使用，因此Android 实际上并不需要 支持多物理用户共同使用。 所以Android将Linux 的多物理用户隔离机制用到了 APP的隔离管理中， 将分配给物理用户的UID 分配给了 运行在Android 系统中的APP ，从而达到了隔离不用APP的效果，奠定了Android 沙箱的基础。</p><p>一般来说，Android 为APP 分配的UID在 10000和 99999之间， 并根据UID为APP生成用户名， 使用id 命令就可以查看APP的和GID信息。</p><p>如果APP申请的权限被授权，则相应权限所在组的GID 会被添加到 APP的进程中， 其中GID 与权限的对应关系在系统文件 platform.xml中定义。</p><p>举例说明： 一个APP的GID 有一个是 inet(3003), 则 inet 组对应的权限是 android.permission.INTERNET, 反映出该APP 具有网络访问权限。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">permission</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android.permission.INTERNET&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">group</span> <span class="hljs-attr">gid</span>=<span class="hljs-string">&quot;inet&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">permission</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">permission</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android.permission.READ_LOGS&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">group</span> <span class="hljs-attr">gid</span>=<span class="hljs-string">&quot;log&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">permission</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">permission</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android.permission.READ_EXTERNAL_STORACE&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">group</span> <span class="hljs-attr">gid</span>=<span class="hljs-string">&quot;sdcard_r&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">group</span> <span class="hljs-attr">gid</span>=<span class="hljs-string">&quot;sdcard_rw&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">permission</span>&gt;</span><br></code></pre></td></tr></table></figure><p>为了满足平板计算机等设备多物理用户的使用需求， 从Android 4.2 开始，在除了手机以外的其他设备均支持多物理用户的使用。由于LInux 的多用户管理特性已经被 Android  用于APP管理， 所以Android 在上层通过用户管理系统服务(UserManagerService）， 重新实现了多用户管理。 关于Android  是否支持多物理用户， 可以在 Android 源代码的 UserHandle.java中查看 MU_ENABLED 是否设置为 true。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">Public</span> <span class="hljs-keyword">static</span> fianl <span class="hljs-keyword">Boolean</span> MU_ENABLED = <span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><p>在多用户使用的情况下， 不同用户可能安装相同的APP， 在前述的运行模式下，不同用户安装相同的APP 时，系统里的UID 是相同的。 为了区分不同的用户安装的APP ，Android 会为每一个安装的APP生成一个新的UID，  保证了即使不同的用户安装了相同的APP， 各自的新“UID”也不会相同，进而获取相互隔离的运行沙箱。</p><p>面向多用户的 “UID”使用过物理用户的ID 和对应的程序ID计算得到的，其中在单物理用户系统下，APPID就是UID，具体的计算方法在 UserHandle.java中找到。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> finale <span class="hljs-type">int</span> <span class="hljs-title">getuid</span><span class="hljs-params">(<span class="hljs-type">int</span> userid , <span class="hljs-type">int</span> appId)</span></span>&#123;<br><span class="hljs-keyword">if</span>(MU_ENABLED)&#123;<br>  <span class="hljs-keyword">return</span>  userId*PER_USER_RANG E+ (app<br>      Id%PER_USER_RANG)&#125;<span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-keyword">return</span> appId&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>0x03 Android  系统沙箱</strong> </p><p>Android 为APP 分配UID， 根据UID 的不同来对不同的APP进行隔离， 将不同的APP分配到不同的沙箱之中。除此之外，Android 沙箱还对APP在存储空间上的安装目录进行限制，不同APP 空间无法互相访问文件，包括文件的读取和写入。</p><p>我们可以把沙箱形象的理解为房间， UID 相当于钥匙，Android 为不同的APP 提供了一个独立的房间，APP通过UID进入各自的房间，房间之间互相隔离。</p><p>当APP安装成功之后， 系统会分配一个UID， UID的值在 &#x2F;data&#x2F;system&#x2F;packages.xml文件中，当APP 或者他的组件需要运行时， 系统便为其创建一个标识该APP UID的进程， 进程实例化一个Dalvik 虚拟机来执行APP的字节码，不同的APP 在各自的 Dalvik 虚拟机中运行。</p><p>APP 在安装之后会在单用户设备的 &#x2F;data&#x2F;data&#x2F; 目录下， 多用户设备在 &#x2F;data&#x2F;user&#x2F;userID 目录下， 以自身的包名为文件名创建文件夹， 存放APP运行所需的文件和资源。 系统用UID 标识 &#x2F;data&#x2F;data&#x2F;[packsges-name] 或者 &#x2F;data&#x2F;user&#x2F;userID[packsges-name]  目录该APP的相关资源， 系统设置权限之后， 非该UID的APP 进程无法访问该UID 标识的文件和资源。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1442084/1642429825282-6b0d8c72-7299-47ee-9276-bd2b921de6d3.png" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>移动安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>移动安全</tag>
      
      <tag>HOOK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zygisk原理简单分析和以及zygisk插件开发</title>
    <link href="/2023/08/31/zygisk%E5%8E%9F%E7%90%86%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E5%92%8C%E4%BB%A5%E5%8F%8Azygisk%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <url>/2023/08/31/zygisk%E5%8E%9F%E7%90%86%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E5%92%8C%E4%BB%A5%E5%8F%8Azygisk%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="zygisk原理简单分析和以及zygisk插件开发"><a href="#zygisk原理简单分析和以及zygisk插件开发" class="headerlink" title="zygisk原理简单分析和以及zygisk插件开发"></a>zygisk原理简单分析和以及zygisk插件开发</h1><p>来自面具作者的文章对于zygisk的介绍</p><blockquote><p>Zygisk是Zygote的Magisk。这将在Zygote进程中运行Magisk的一部分，使Magisk模块更强大。这也是Magisk”退出舞台”理念中非常重要的一部分。当某一个进程位于上述拒绝列表中时，Magisk 将清理该过程的内存空间，以确保不会应用任何修改（P.S.1）。当然，Zygisk 仍然是 WIP（开发中）的，一旦实施准备好测试，会公布更多细节。</p></blockquote><h4 id="对于zygisk的理解"><a href="#对于zygisk的理解" class="headerlink" title="对于zygisk的理解"></a>对于zygisk的理解</h4><ul><li>zygisk依然是magisk，但是是更高级的版本，带了注入Zygote功能。</li><li>zygisk的开启是可选的，在magisk设置。如不开启将和原来差不多。</li><li>zygisk将提供超过之前magisk的功能，尤其是注入hook。所以可以基于zygisk开发出lsp(新的xp框架)而且不基于riru。</li><li>riru和zygisk对Zygote的修改部分重复了，所以二者不能很好共存。</li><li>zygisk没有hide，因为作者加入了谷歌之后不再做检测对抗了。</li></ul><h3 id="magisk实现原理"><a href="#magisk实现原理" class="headerlink" title="magisk实现原理"></a>magisk实现原理</h3><p>在magisk上有一行说明:systemless root</p><p>那么这个systemless是什么东西</p><p>在了解systemless之前我们还要了解什么是root以及如何获得root</p><h4 id="root原理-来自网络"><a href="#root原理-来自网络" class="headerlink" title="root原理(来自网络)"></a>root原理(来自网络)</h4><p><strong>下面是来自网络的root解释，年代已久不过我感觉还是有用的。</strong></p><p>root权限就是root(管理员权限)用户的权限，该权限可以修改根目录下的文件</p><p>为了让我们的应用使用root权限</p><p>首先我们需要一个处理root请求的 su 进程</p><p>我们链接手机到电脑 输入adb shell</p><p>再输入 su 如果没root就会提示 su文件找不到</p><p>ok 既然没有这个文件那我们就push这个su执行文件到<br>&#x2F;system&#x2F;bin 下面吧</p><p>不行，因为你没有root权限所以不能向system传输文件</p><p>同样的因为你不能传输文件也就不能植入su 应用程序</p><p>也就是没法让你获得root权限 这就是死循环</p><h6 id="之前的root方式"><a href="#之前的root方式" class="headerlink" title="之前的root方式"></a>之前的root方式</h6><p>这个不细说了</p><ul><li>利用系统漏洞提权注入。这个方式很多，早期版本的系统用的多。现在系统越来越安全基本难以实现。</li><li>定制内核修改system分区的方式。</li><li>厂商会定制开发版本自带root权限。在于本身ASOP就支持userdebug版本模式去编译的。</li></ul><h5 id="systemless-root"><a href="#systemless-root" class="headerlink" title="systemless root"></a>systemless root</h5><p>之前的root会对system目录做文件修改</p><p>而systemless root 则不会对system目录做任何修改</p><p>这是为了应对高版本的系统的检测</p><p>基于systemless的root就是 systemless root</p><p>magisk 是实现 systemless root 的一个方式，实际上在magisk之前就有systemless root。只不过magisk把这个发扬光大了。</p><h4 id="magisk实现方式"><a href="#magisk实现方式" class="headerlink" title="magisk实现方式"></a>magisk实现方式</h4><p>在之前做过magisk的分析，我把答案抄过来。</p><h5 id="magisk刷入过程"><a href="#magisk刷入过程" class="headerlink" title="magisk刷入过程"></a>magisk刷入过程</h5><ul><li>安装magisk apk</li><li>提取boot.img</li><li>制作修改的patch_boot.img</li><li>刷入patch_boot.img开机即可</li></ul><p>不难得出核心在于针对boot.img文件的修改</p><p>那么修改的patch_boot.img具体做了什么是我们最关心的</p><h5 id="启动日志分析"><a href="#启动日志分析" class="headerlink" title="启动日志分析"></a>启动日志分析</h5><p>开机 打开面具的日志这里</p><p><img src="https://bbs.pediy.com/upload/attach/202204/832784_5BTUUB5KNMVV34Z.png" alt="img"></p><p>可以看到这里在</p><p><code>/sbin/.magisk/mirror</code> 下面建立了一个系统根目录的镜像目录</p><p>我们打开文件的时候就会发现 sbin 里面还拥有一个su执行文件和模块插件等其他文件</p><p>然后进行 bind mounted 操作，也就是让这个文件系统生效。</p><p>这时候ps -A其实就可以看到 su 进程，也就有了授权root的能力。</p><p>接下来就可以用magisk来管理root权限，请求root的都会出现在<code>超级用户</code>这个列表里。</p><p>同时基于 bind mount 可以针对系统文件进行替换以及在这里执行sh脚本，这就是我们写的magisk模块的实现了。</p><blockquote><p>非常多的细节可以在<a href="https://topjohnwu.github.io/Magisk/details.html">https://topjohnwu.github.io/Magisk/details.html</a> 里面得到，或许我的理解会有误差。</p></blockquote><h3 id="zygisk实现原理"><a href="#zygisk实现原理" class="headerlink" title="zygisk实现原理"></a>zygisk实现原理</h3><p>在了解zygisk之前，先了解magisk的功能实现原理。我这里分析zygisk关于注入Zygote的逻辑。</p><h4 id="实现原理猜想"><a href="#实现原理猜想" class="headerlink" title="实现原理猜想"></a>实现原理猜想</h4><p>在分析之前我就在猜想他的实现原理了。</p><blockquote><p>xposed注入Zygote原理是替换 app_process，而magisk可以做到替换系统文件。那么magisk是不是可以替换app_process来注入Zygote。</p></blockquote><p>虽然zygisk是新一点东西 好在已经有人分析过了。可以踩在巨人的肩上了。</p><h4 id="验证猜想"><a href="#验证猜想" class="headerlink" title="验证猜想"></a>验证猜想</h4><p>在magisk仓库里面搜索 <code>app_process</code> 果然找到了相关代码</p><p>打开<a href="https://github.com/topjohnwu/Magisk/blob/9e8218089bdca649aa27a76961fbfba8a24ef3f5/native/jni/zygisk/main.cpp">main.cpp</a>看到一行注释</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> Entrypoint <span class="hljs-keyword">for</span> app_process overlay<br></code></pre></td></tr></table></figure><p>确认无疑了,对app_process进行了替换</p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p><a href="https://gist.github.com/5ec1cff/bfe06429f5bf1da262c40d0145e9f190#file-zygisk-md"><br>Zygisk 源码分析</a> 实际上这篇文章已经写的非常详细了，我加上了一点自己的理解。算是拾人牙慧了。</p><h5 id="太长不看版本"><a href="#太长不看版本" class="headerlink" title="太长不看版本"></a>太长不看版本</h5><p>先总结一下整个流程</p><ul><li><code>module.cpp</code>中判断是否开启<code>zygisk_enabled</code>,是就进入<br>mount_zygisk进行 <code>app_process</code>的 mount，将<br><code>app_process</code>替换成<code>magisk</code></li><li><code>main.cpp</code> 是<code>magisk</code>执行文件，作用是替换<code>app_process</code>工作(原理是用 LD_PRELOAD 注入)</li><li><code>entry.cpp</code>加载Zygisk，分为两个阶段加载。一阶段dlopen载入二阶段，二阶段进行hook。 其他的细节包括hide hook处理看源码分析。</li></ul><h5 id="注入阶段"><a href="#注入阶段" class="headerlink" title="注入阶段"></a>注入阶段</h5><h6 id="native-jni-core-module-cpp"><a href="#native-jni-core-module-cpp" class="headerlink" title="native&#x2F;jni&#x2F;core&#x2F;module.cpp"></a>native&#x2F;jni&#x2F;core&#x2F;module.cpp</h6><p>搜索 <code>app_process</code> 出现最多的就是这个module.cpp文件</p><p>打开文件看到<code>bind_mount</code> 就知道这个类对文件进行了挂载。</p><p>对<code>app_process</code>进行处理的函数在<code>magic_mount</code>中</p><blockquote><p>mount是Linux下的一个命令，它可以将分区挂接到Linux的一个文件夹下，从而将分区和该目录联系起来，因此我们只要访问这个文件夹，就相当于访问该分区了。</p></blockquote><p><img src="https://bbs.pediy.com/upload/attach/202204/832784_UP2TFAZ8N7TSMS7.png" alt="img"></p><p>新建文件夹后<code>mount_zygisk</code>处理挂载文件夹</p><h6 id="mount-zygisk-函数"><a href="#mount-zygisk-函数" class="headerlink" title="mount_zygisk 函数"></a>mount_zygisk 函数</h6><p><img src="https://bbs.pediy.com/upload/attach/202204/832784_HEHQW7HWX9DREUD.png" alt="img"></p><p>两件事:文件移动和文件夹挂载</p><p>app_process 32&#x2F;64 放到了zygisk下面<br>magisk 32&#x2F;64 放到了 <code>MAGISKTMP</code> 下面</p><p>完成文件的<code>app_process</code>到<code>magisk</code>的替换</p><p>做完这些之后，我们重启手机启动运行的<code>app_process</code>其实就是运行<code>magisk</code></p><p>我们其实可以看到这些文件的</p><p><img src="https://bbs.pediy.com/upload/attach/202204/832784_2KUQFDJ7T7SWMSA.png" alt="img"></p><h5 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h5><p>这部分核心研究跑起来的magisk跑起来之后具体做了什么</p><p>包括hook的实现逻辑</p><h6 id="native-jni-zygisk-main-cpp"><a href="#native-jni-zygisk-main-cpp" class="headerlink" title="native&#x2F;jni&#x2F;zygisk&#x2F;main.cpp"></a>native&#x2F;jni&#x2F;zygisk&#x2F;main.cpp</h6><p>运行了magisk文件，现在进入他的函数分析他的逻辑。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">Entrypoint</span><span class="language-bash"> <span class="hljs-keyword">for</span> app_process overlay</span><br></code></pre></td></tr></table></figure><p>对着这个注释往下看</p><h6 id="app-process-main-函数"><a href="#app-process-main-函数" class="headerlink" title="app_process_main 函数"></a>app_process_main 函数</h6><p>通过socker通信设置几个变量的值 LD_PRELOAD INJECT_ENV_1<br>MAGISKTMP_ENV</p><p><code>ZygiskRequest::SETUP</code>是通信的标志</p><p><img src="https://bbs.pediy.com/upload/attach/202204/832784_SPK8FMMQYKYUSUX.png" alt="img"></p><p>这里非常核心的一个就是 LD_PRELOAD 变量的值设置，这将作用到后面的注入</p><blockquote><p>LD_PRELOAD是Linux系统的一个环境变量，它可以影响程序的运行时的链接（Runtime linker），它允许你定义在程序运行前优先加载的动态链接库。</p></blockquote><h5 id="native-jni-zygisk-entry-cpp"><a href="#native-jni-zygisk-entry-cpp" class="headerlink" title="native&#x2F;jni&#x2F;zygisk&#x2F;entry.cpp"></a>native&#x2F;jni&#x2F;zygisk&#x2F;entry.cpp</h5><p>找到消息接收的地方</p><p><img src="https://bbs.pediy.com/upload/attach/202204/832784_6NUS7AJW9YSMEU8.png" alt="img"></p><h6 id="进入setup-files函数"><a href="#进入setup-files函数" class="headerlink" title="进入setup_files函数"></a>进入setup_files函数</h6><p><img src="https://bbs.pediy.com/upload/attach/202204/832784_Y43ZSM4SQ4NV4G5.png" alt="img"></p><p>buf 获取了可执行路径<br>sendfd 发送持有的真正的 app_process 文件 fd<br>write_string 发送 MAGISKTMP 路径</p><p>到这里我开始发现与参考文件不同的地方了</p><p>尤其是</p><p><img src="https://bbs.pediy.com/upload/attach/202204/832784_4EBXM3RNV62GGH5.png" alt="img"></p><p>根本对不上，zygisk下面也没有对应的so文件</p><p>那就是改版了，下面就自己分析新版zygisk的原理吧</p><h5 id="native-jni-zygisk-entry-cpp-1"><a href="#native-jni-zygisk-entry-cpp-1" class="headerlink" title="native&#x2F;jni&#x2F;zygisk&#x2F;entry.cpp"></a>native&#x2F;jni&#x2F;zygisk&#x2F;entry.cpp</h5><p><img src="https://bbs.pediy.com/upload/attach/202204/832784_WUGERUUC2XQ2SJA.png" alt="img"></p><p>zyg_init函数</p><p>这里进行两阶段的加载操作</p><ul><li>判断<code>INJECT_ENV_1</code> 进行一阶段加载 这个在 <code>app_process_main</code>进行设置的</li><li>在一阶段加载加载完成阶段设置二阶段标志 <code>INJECT_ENV_2</code></li></ul><p>下面分析两个阶段的事情</p><h6 id="first-stage-entry"><a href="#first-stage-entry" class="headerlink" title="first_stage_entry"></a>first_stage_entry</h6><p>一阶段:好在作者加了大段注释 ，我谷歌翻译一遍</p><p><img src="https://bbs.pediy.com/upload/attach/202204/832784_5ENZ5BJF25SY8NM.png" alt="img"></p><p>在这里我发现 LD_PRELOAD 是个非常重要的变量</p><p>修改这个值就可以加载我们的注入的程序</p><p>这里一阶段就是来加载 <code>LD_PRELOAD</code> 的文件</p><p>这个文件就是之前 <code>app_process_main</code>设置的</p><p>获取fd的值这里最终将这个值写入到 <code>MAGISKFD_ENV</code> 中</p><p>同时进行第一次的 <code>android_dlopen_ext</code></p><h6 id="second-stage-entry"><a href="#second-stage-entry" class="headerlink" title="second_stage_entry"></a>second_stage_entry</h6><p>获取<code>MAGISKFD_ENV</code>的值进行 path</p><p>进入 <code>android_dlopen_ext</code> 再一次 dlopen 并立马关闭</p><p>恢复 变量 <code>MAGISKTMP_ENV</code> <code>MAGISKFD_ENV</code></p><p><img src="https://bbs.pediy.com/upload/attach/202204/832784_3DP44KQMFWSZGAE.png" alt="img"></p><p>在结束的时候,调用了</p><ul><li>sanitize_environ();</li><li>hook_functions();</li></ul><p><code>sanitize_environ</code> 字面意思就是 消毒环境。就是用于对抗检测的，消灭证据。具体实现这里不是重点。</p><p><code>hook_functions</code> 具体的hook实现部分</p><h4 id="hook实现"><a href="#hook实现" class="headerlink" title="hook实现"></a>hook实现</h4><p>我们已经将自己的文件注入进去，现在要实现hook</p><h6 id="native-jni-zygisk-hook-cpp"><a href="#native-jni-zygisk-hook-cpp" class="headerlink" title="native&#x2F;jni&#x2F;zygisk&#x2F;hook.cpp"></a>native&#x2F;jni&#x2F;zygisk&#x2F;hook.cpp</h6><p>核心的hook_functions 处于这个类</p><p><img src="https://bbs.pediy.com/upload/attach/202204/832784_D5YKSSDURV76D89.png" alt="img"></p><p>我们核心关注<code>XHOOK_REGISTER(ANDROID_RUNTIME, jniRegisterNativeMethods);</code> 这部分的逻辑</p><p>在之前的riru分析中，我们已经了解过这种hook的实现方法。基于xhook，对register方法进行hook后做个指针的切换。</p><p>几个重要的宏定义</p><p><code>XHOOK_REGISTER</code> 宏<br>使用 xhook register</p><p><img src="https://bbs.pediy.com/upload/attach/202204/832784_U73PGAUGJF392U7.png" alt="img"></p><p><code>DCL_HOOK_FUNC</code> 宏<br>对函数进行hook<br><img src="https://bbs.pediy.com/upload/attach/202204/832784_6X3VMCR5RAC6A9E.png" alt="img"></p><p><code>DCL_PRE_POST</code> 宏<br>定义函数的per和post两种</p><p><img src="https://bbs.pediy.com/upload/attach/202204/832784_GGTE47BUQBAGSW4.png" alt="img"></p><p><img src="https://bbs.pediy.com/upload/attach/202204/832784_5BGFHT8KZ6DKWZ4.png" alt="img"></p><p>比如 fork定义了 fork_pre 和 fork_post</p><p>挑一对 pre和post来分析</p><h5 id="nativeSpecializeAppProcess-pre-nativeSpecializeAppProcess-post"><a href="#nativeSpecializeAppProcess-pre-nativeSpecializeAppProcess-post" class="headerlink" title="nativeSpecializeAppProcess_pre&#x2F;nativeSpecializeAppProcess_post"></a>nativeSpecializeAppProcess_pre&#x2F;nativeSpecializeAppProcess_post</h5><p><img src="https://bbs.pediy.com/upload/attach/202204/832784_N22CM37FZNS2JH9.png" alt="img"></p><p>可以发现核心就是两个</p><ul><li>run_modules_pre(module_fds);</li><li>run_modules_post();</li></ul><p>也就是运行modules插入的hook代码</p><p>这个两个方法需要记得后面继续分析。</p><h6 id="hookAndSaveJNIMethods"><a href="#hookAndSaveJNIMethods" class="headerlink" title="hookAndSaveJNIMethods"></a>hookAndSaveJNIMethods</h6><p>执行hook操作的方法 核心的hook逻辑</p><p><img src="https://bbs.pediy.com/upload/attach/202204/832784_TURK35ATT92QWFD.png" alt="img"></p><h6 id="HOOK-JNI"><a href="#HOOK-JNI" class="headerlink" title="HOOK_JNI"></a>HOOK_JNI</h6><p>三个函数的hook</p><ul><li>HOOK_JNI(nativeForkAndSpecialize)</li><li>HOOK_JNI(nativeSpecializeAppProcess)</li><li>HOOK_JNI(nativeForkSystemServer)</li></ul><p>这三个函数是app进程启动的Zygote中三个相关函数，是应用进程或者系统服务进程被fork 出来的时候会调用的方法。</p><p><img src="https://bbs.pediy.com/upload/attach/202204/832784_QZ2NF7P2BJ3HZGW.png" alt="img"></p><p>实现hook后引入</p><h5 id="native-jni-zygisk-jni-hooks-hpp"><a href="#native-jni-zygisk-jni-hooks-hpp" class="headerlink" title="native&#x2F;jni&#x2F;zygisk&#x2F;jni_hooks.hpp"></a>native&#x2F;jni&#x2F;zygisk&#x2F;jni_hooks.hpp</h5><p>实现具体hook的地方，在这里区分了版本和手机类型。将新旧方法做了保存和指针更换处理。</p><p><img src="https://bbs.pediy.com/upload/attach/202204/832784_Y7AXMYBR2X3TMSN.png" alt="img"></p><p>比如这个就是安卓Q版本的hook处理逻辑，这里有个重要的<code>HookContext</code>结构体。</p><p>核心的三句</p><ul><li>ctx.nativeSpecializeAppProcess_pre();</li><li>reinterpret_cast&lt;decltype(&amp;nativeSpecializeAppProcess_q)&gt;(nativeSpecializeAppProcess_orig)( env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name,<br>is_child_zygote, instruction_set, app_data_dir);</li><li>ctx.nativeSpecializeAppProcess_post();</li></ul><p><code>pre</code>和<code>post</code>调用用于执行插入的hook code。</p><p>而中间那句就是执行原方法<code>orgin</code></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>分析到这里差不多，未完待续。后面还有关于如何zygisk屏蔽应用以及如何load moudules 代码的有时间再说。</p><p>参考<a href="https://gist.github.com/5ec1cff/bfe06429f5bf1da262c40d0145e9f190#file-zygisk-md"><br>Zygisk 源码分析</a></p>]]></content>
    
    
    <categories>
      
      <category>移动安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>移动安全</tag>
      
      <tag>HOOK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的hook技术方案</title>
    <link href="/2023/08/31/%E5%B8%B8%E8%A7%81%E7%9A%84hook%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"/>
    <url>/2023/08/31/%E5%B8%B8%E8%A7%81%E7%9A%84hook%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="常见的hook技术方案"><a href="#常见的hook技术方案" class="headerlink" title="常见的hook技术方案"></a>常见的hook技术方案</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>最近一段时间在研究Android加壳和脱壳技术，其中涉及到了一些hook技术，于是将自己学习的一些hook技术进行了一下梳理，以便后面回顾和大家学习。</p><p>本文第二节主要讲述编译原理，了解编译原理可以帮助进一步理解hook技术</p><p>本文第三节主要讲述NDK开发的一些基础知识</p><p>本文第四节主要讲述各类hook技术的实现原理</p><p>本文第五节主要讲述各hook技术的实现步骤和案例演示</p><h2 id="二、编译原理"><a href="#二、编译原理" class="headerlink" title="二、编译原理"></a>二、编译原理</h2><h3 id="1-编译过程"><a href="#1-编译过程" class="headerlink" title="1.编译过程"></a>1.编译过程</h3><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_JC5TBVTX9ZNWVFV.png" alt="image-20210918161352124"></p><p>我们可以借助gcc来实现上面的过程：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">预处理阶段：预处理器（cpp）根据以字符``#开头的命令修给原始的C程序，结果得到另一个C程序，通常以.i作为文件扩展名。主要是进行文本替换、宏展开、删除注释这类简单工作。``  ``命令行：gcc ``-``E hello.c hello.i``编译阶段：将文本文件hello.i翻译成hello.s，包含相应的汇编语言程序``汇编阶段：将.S文件翻译成机器指令，然后把这些指令打包成一种可重定位目标程序的格式，并把结果保存在目标文件.o中（汇编——&gt;机器）``  ``命令行：gcc ``-``c hello.c hello.o``链接阶段：hello程序调用了printf函数，链接器（``Id``）就把printf.o文件并入hello.o文件中，得到hello可执行文件，然后加载到存储器中由系统执行。``  ``函数库包括静态库和动态库``  ``静态库：编译链接时，把库文件代码全部加入可执行文件中，运行时不需要库文件，后缀为.a。``  ``动态库：编译链接时，不加入，在程序执行时，由运行时链接文件加载库，这样节省开销，后缀为.so。（gcc编译时默认使用动态库）``再经过汇编器和连接器的作用后输出一个目标文件，这个目标文件为可执行文件<br></code></pre></td></tr></table></figure><p>显示详细信息</p><p>这里我们对编译过程做了一个初步的讲解，详细大家可以去看《程序员的自我修养——链接、装载与库》一书，下面我们主要介绍链接方式、链接库、可执行目标文件几个基本概念。</p><h4 id="（1）链接方式"><a href="#（1）链接方式" class="headerlink" title="（1）链接方式"></a>（1）链接方式</h4><p><strong>静态链接：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">对于静态库，程序在编译链接时，将库的代码链接到可执行文件中，程序运行时不再需要静态库。在使用过程中只需要将库和我们的程序编译后的文件链接在一起就可形成一个可执行文件。<br></code></pre></td></tr></table></figure><p><strong>缺点：</strong></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs r"><span class="hljs-number">1</span>``、内存和磁盘空间浪费：静态链接方式对于计算机内存和磁盘的空间浪费十分严重。假如一个<span class="hljs-built_in">c</span>语言的静态库大小为``1MB``，系统中有``100``个需要使用到该库文件，采用静态链接的话，就要浪费进``100M``的内存，若数量再大，那浪费的也就更多。``2.``更新麻烦：比如一个程序``20``个模块，每个模块只有``1MB``，那么每次更新任何一个模块，用户都得重新下载``20M``的程序<br></code></pre></td></tr></table></figure><p><strong>动态链接：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">由于静态链接具有浪费内存和模块更新困难等问题，提出了动态链接。基本实现思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将他们链接在一起形成一个完整的程序，而不是像静态链接那样把所有的程序模块都链接成一个单独的可执行文件。所以动态链接是将链接过程推迟到了运行时才进行。<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">同样，假如有程序<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>，程序<span class="hljs-string">``</span><span class="hljs-number">2</span><span class="hljs-string">``</span>，和Lib.o三个文件，程序<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>和程序<span class="hljs-string">``</span><span class="hljs-number">2</span><span class="hljs-string">``</span>在执行时都需要用到Lib.o文件，当运行程序<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>时，系统首先加载程序<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>，当发现需要Lib.o文件时，也同样加载到内存，再去加载程序<span class="hljs-string">``</span><span class="hljs-number">2</span><span class="hljs-string">``</span>当发现也同样需要用到Lib.o文件时，则不需要重新加载Lib.o，只需要将程序<span class="hljs-string">``</span><span class="hljs-number">2</span><span class="hljs-string">``</span>和Lib.o文件链接起来即可，内存中始终只存在一份Lib.o文件。<br></code></pre></td></tr></table></figure><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_PBRES2N9MDUUJG2.png" alt="image-20210918161352124"></p><p>优点：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">（<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>）毋庸置疑的就是节省内存；<span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">2</span><span class="hljs-string">``</span>）减少物理页面的换入换出；<span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">3</span><span class="hljs-string">``</span>）在升级某个模块时，理论上只需要将对应旧的目标文件覆盖掉即可。新版本的目标文件会被自动装载到内存中并且链接起来；<span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">4</span><span class="hljs-string">``</span>）程序在运行时可以动态的选择加载各种程序模块，实现程序的扩展。<br></code></pre></td></tr></table></figure><h4 id="（2）链接库"><a href="#（2）链接库" class="headerlink" title="（2）链接库"></a>（2）链接库</h4><p>我们在链接的过程中，一般会链接一些库文件，主要分为静态链接库和动态链接库。静态链接库一般为<code>Windows下的.lib和Linux下的.a</code>,动态链接库一般为<code>Windows下的.dll和Linux下的.so</code>，这里考虑到我们主要是对so文件hook讲解，下面我们主要介绍linux系统下的情况。</p><p><strong>静态库：</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">命名规范为libXXX.a<span class="hljs-string">``</span>库函数会被连接进可执行程序，可执行文件体积较大<span class="hljs-string">``</span>可执行文件运行时，不需要从磁盘载入库函数，执行效率较高<span class="hljs-string">``</span>库函数更新后，需要重新编译可执行程序<br></code></pre></td></tr></table></figure><p><strong>动态库：</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">命名规范为libXXX.so<span class="hljs-string">``</span>库函数不被连接进可执行程序，可执行文件体积较小<span class="hljs-string">``</span>可执行文件运行时，库函数动态载入<span class="hljs-string">``</span>使用灵活，库函数更新后，不需要重新编译可执行程序<br></code></pre></td></tr></table></figure><h3 id="2-可执行文件（ELF）"><a href="#2-可执行文件（ELF）" class="headerlink" title="2.可执行文件（ELF）"></a>2.可执行文件（ELF）</h3><p>目前PC平台比较流行的可执行文件格式主要是Windows下的PE和Linux下的ELF，它们都是COFF格式的变种。在Windows平台下就是我们比较熟悉的.exe文件，而Linux平台下现在便是统称的ELF文件。这里我们主要介绍一下Linux下的ELF文件。</p><p><strong>ELF文件的类型：</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">可重定位目标文件：包含二进制代码和数据，其形式可以和其他目标文件进行合并，创建一个可执行目标文件。比如linux下的.o文件<span class="hljs-string">``</span>可执行目标文件：包含二进制代码和数据，可直接被加载器加载执行。 比如<span class="hljs-string">``</span>/<span class="hljs-string">``</span>bin<span class="hljs-string">``</span>/<span class="hljs-string">``</span>sh文件<span class="hljs-string">``</span>共享目标文件：可被动态的加载和链接。比如.so文件<br></code></pre></td></tr></table></figure><p><strong>ELF文件的结构：</strong></p><p>elf文件在不同的平台上有不同的格式，在Unix和x86-64 Linux上称ELF：</p><h4 id="（1）ELF文件结构"><a href="#（1）ELF文件结构" class="headerlink" title="（1）ELF文件结构"></a>（1）ELF文件结构</h4><p>目标文件既要参与程序链接，又要参与程序执行：</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_7TFTERM5FTMWAVF.png" alt="image-20220517112124280"></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">(<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>)文件开始处：是一个ELF头部（ELF <span class="hljs-keyword">Header</span>），用来描述整个文件的组织。节区部分包含链接视图的大量信息：指令、数据、符号表、重定位信息等。<span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-number">2</span><span class="hljs-string">``</span>)程序头部表(Program <span class="hljs-keyword">Header</span> Table)：如果存在的话，会告诉系统如何创建进程映像。用来构造进程映像的目标文件必须具有程序头部表，可重定位文件不需要这个表。<span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-number">3</span><span class="hljs-string">``</span>)节区头部表(Section <span class="hljs-keyword">Header</span> Table)：包含了描述文件节区的信息，每个节区在表中都有一项，每一项给出诸如节区名称、节区大小这类信息。用于链接的目标文件必须包含节区头部表，其他目标文件可以有，也可以没有这个表。<br></code></pre></td></tr></table></figure><p>下面我们来从分别从连接视角和程序执行的视角来看ELF文件：</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_5N6DT5YSG5SHXYY.png" alt="image-20210918161352124"></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">ELF</span> <span class="hljs-selector-tag">Header</span>:描述了描述了体系结构和操作系统等基本信息并指出<span class="hljs-selector-tag">Section</span> <span class="hljs-selector-tag">Header</span> <span class="hljs-selector-tag">Table</span>和<span class="hljs-selector-tag">Program</span> <span class="hljs-selector-tag">Header</span> <span class="hljs-selector-tag">Table</span>在文件中的什么位置``<span class="hljs-selector-tag">Program</span> <span class="hljs-selector-tag">Header</span> <span class="hljs-selector-tag">Table</span>: 保存了所有<span class="hljs-selector-tag">Segment</span>的描述信息；在汇编和链接过程中没有用到，所以是可有可无的``<span class="hljs-selector-tag">Section</span> <span class="hljs-selector-tag">Header</span> <span class="hljs-selector-tag">Table</span>:保存了所有<span class="hljs-selector-tag">Section</span>的描述信息；<span class="hljs-selector-tag">Section</span> <span class="hljs-selector-tag">Header</span> <span class="hljs-selector-tag">Table</span>在加载过程中没有用到，所以是可有可无的<br></code></pre></td></tr></table></figure><p>下面我们来看一张更加详细的ELF结构图</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_34AAE6M4KDSPFPX.png" alt="image-20210918161352124"></p><p>从中我们可以详细的知道ELF文件各个字段的含义，其他字段的含义如下图</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_TFE3WYCC7Q4QHHR.png" alt="image-20210918161352124"></p><h4 id="（2）GOT和PLT"><a href="#（2）GOT和PLT" class="headerlink" title="（2）GOT和PLT"></a>（2）GOT和PLT</h4><p>上面我们简单的分析了ELF的文件结构，而这里我们介绍一下其中两个重要的节表<code>GOT(全局偏移表)</code>和<code>PLT(程序链接表)</code></p><p>首先，我们需要理解为什么需要GOT表和PLT表</p><p>经过上面的分析，我们知道程序在经历了编译流程后，就来到了链接过程，链接过程就是将一个或者多个中间文件（.o文件）通过链接器将它们链接成一个可执行文件，主要要完成以下事情：</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-number">1</span>.<span class="hljs-string">``</span>各个中间文之间的同名<span class="hljs-keyword">section</span>合并<span class="hljs-string">``</span><span class="hljs-number">2</span>.<span class="hljs-string">``</span>对代码段，数据段以及各符号进行地址分配<span class="hljs-string">``</span><span class="hljs-number">3</span>.<span class="hljs-string">``</span>链接时重定位修正<br></code></pre></td></tr></table></figure><p>但是当我们程序运行起来，<code>glibc</code>动态库也装载了，函数地址也确定了，那我们程序如何去调用动态库中的函数呢，这个时候就需要理解一下重定位的概念：</p><p><strong>重定位：</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-number">1.</span><span class="hljs-string">``</span>链接重定位：将一个或多个中间文件(.o文件)通过链接器将它们链接成一个可执行文件，一般分为两种情况：<span class="hljs-string">``</span>  <span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>）如果是在其他中间文件中已经定义了的函数，链接阶段可以直接重定位到函数地址，比如我们从头文件访问另一个函数<span class="hljs-string">``</span>  <span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">2</span><span class="hljs-string">``</span>）如果是在动态库中定义了的函数，链接阶段无法直接重定位到函数地址，只能生成额外的小片段代码，也就是PLT表，然后重定位到该代码片段<span class="hljs-string">``</span><span class="hljs-number">2.</span><span class="hljs-string">``</span>运行重定位：运行后加载动态库，把动态库中的相应函数地址填入GOT表，由于PLT表是跳转到GOT表的，这就构成了运行时重定位<span class="hljs-string">``</span><span class="hljs-number">3.</span><span class="hljs-string">``</span>延迟重定位：只有动态库函数在被调用时，才会进行地址解析和重定位工作，这时候动态库函数的地址才会被写入到GOT表项中<br></code></pre></td></tr></table></figure><p>这里我们就可以明白流程，程序在加载动态库中函数时，需要两部分：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">需要存放外部函数的代码段表（PLT表）<span class="hljs-string">``</span>存放函数地址的数据表（GOT表）<br></code></pre></td></tr></table></figure><p>这里我用一个实例加深大家的理解，例如程序在链接时发现scanf定义在动态库时，链接器生成一小段代码scanf_stub,这就是我们的PLT表，然后scanf_stub地址取代原来的scanf,因此程序此时就转换为链接scanf_stub，这个过程叫链接重定位，然后在运行时动态库glibc中的scanf_libc地址填入GOT表，然后程序通过scanf_stub访问到scanf_libc，这个过程叫运行时重定位。</p><p>讲到这里，其实我们对PLT和GOT表的作用已经了解了，<code>PLT（程序链接表）</code>就是链接时需要存放外部函数的数据段，<code>GOT（全局偏移表）</code>是存放函数地址的代码</p><p><strong>PLT和GOT的结构：</strong></p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">PLT表中的第一项为公共表项，剩下的是每个动态库函数为一项,每项PLT都从对应的GOT表项中读取目标函数地址` `GOT表中前``<span class="hljs-number">3</span>``个为特殊项，分别用于保存 .dynamic段地址、本镜像的link_map数据结构地址和_dl_runtime_resolve函数地址``dynamic段：提供动态链接的信息，例如动态链接中各个表的位置``link_map：已加载库的链表，由动态库函数的地址构成的链表``_dl_runtime_resolve：在第一次运行时进行地址解析和重定位工作<br></code></pre></td></tr></table></figure><p>根据操作系统规定不允许修改代码段，只能修改数据段，所以PLT表是不变的，GOT表是可以改变的</p><table><thead><tr><th>.plt</th><th>代码段</th><th>RE（可读，可执行）</th><th>.plt section 实际就是通常所说的过程链接表（Procedure Linkage Table, PLT）</th></tr></thead><tbody><tr><td>.plt.got</td><td>代码段</td><td>RE</td><td>.plt.got section 用于存放 __cxa_finalize 函数对应的 PLT 条目</td></tr><tr><td>.got</td><td>数据段</td><td>RW（可读，可写）</td><td>.got section 中可以用于存放全局变量的地址；.got section 中也可以用于存放不需要延迟绑定的函数的地址。</td></tr><tr><td>.got.plt</td><td>数据段</td><td>RW</td><td>.got.plt section 用于存放需要延迟绑定的函数的地址</td></tr></tbody></table><p>因此我们可以看一下程序调用PLT表和GOT表的逻辑</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_E2EUR5PYRBX7ZB2.png" alt="image-20220517105915852"></p><p>最后我们来详细看一下程序调用函数的变化流程：</p><p><strong>程序第一次调用函数时：</strong></p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_DJSS6R4KNDG87XM.png" alt="image-20220517105915852"></p><p>此时第一步由函数调用跳入到PLT表中，然后第二步PLT表跳到GOT表中，可以看到第三步由GOT表回跳到PLT表中，这时候进行压栈，把代表函数的ID压栈，接着第四步跳转到公共的PLT表项中，第5步进入到GOT表中，然后_dl_runtime_resolve对动态函数进行地址解析和重定位，第七步把动态函数真实的地址写入到GOT表项中，然后执行函数并返回，此时GOT表中就存放了函数的真实地址</p><p><strong>之后函数被调用时：</strong></p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_AVAS94K9B65W2CH.png" alt="image-20220517105915852"></p><p>第一步还是由函数调用跳入到PLT表，但是第二步跳入到GOT表中时，由于这个时候该表项已经是动态函数的真实地址了，所以可以直接执行然后返回</p><h2 id="三、NDK基础知识"><a href="#三、NDK基础知识" class="headerlink" title="三、NDK基础知识"></a>三、NDK基础知识</h2><p>这里我们主要介绍Android中的so文件加载的原理，为后面hook技术讲解做铺垫：</p><h3 id="1-Android-so文件的类型"><a href="#1-Android-so文件的类型" class="headerlink" title="1.Android so文件的类型"></a>1.Android so文件的类型</h3><p>NDK开发的so不再具备跨平台特性，需要编译提供不同平台支持</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_JD8BB3AV53PKUH3.png" alt="image-20210919152200104"></p><p>我们从官网可以得知so文件在不同架构下也不同，这里依次对应<code>arm32位和64位，x86_32位和64位</code></p><p>我们可以使用指令查看我们手机的架构：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">adb shell<span class="hljs-string">``</span>cat <span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-built_in">proc</span><span class="hljs-string">``</span>/<span class="hljs-string">``</span>cpuinfo<br></code></pre></td></tr></table></figure><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_8B8V7Q8RVKM4QH6.png" alt="image-20210919155021588"></p><h3 id="2-so文件加载"><a href="#2-so文件加载" class="headerlink" title="2.so文件加载"></a>2.so文件加载</h3><p>Android中我们通常使用系统提供的两种API：System.loadLibrary或者System.load来加载so文件：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>加载的是libnative<span class="hljs-string">``</span>-<span class="hljs-string">``</span>lib.so，注意的是这边只需要传入<span class="hljs-string">``</span><span class="hljs-string">&quot;native-lib&quot;</span><span class="hljs-string">``</span>System.loadLibrary(<span class="hljs-string">``</span><span class="hljs-string">&quot;native-lib&quot;</span><span class="hljs-string">``</span>);<span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>传入的是so文件完整的绝对路径<span class="hljs-string">``</span>System.load(<span class="hljs-string">``</span><span class="hljs-string">&quot;/data/data/应用包名/lib/libnative-lib.so&quot;</span><span class="hljs-string">``</span>)<br></code></pre></td></tr></table></figure><p>System.loadLibrary()和System.load()的区别：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">（<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>）loadLibray传入的是编译脚本指定生成的so文件名称，一般不需要包含开头的lib和结尾的.so，而load传入的是so文件所在的绝对路径<span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">2</span><span class="hljs-string">``</span>）loadLibrary传入的不能是路径，查找so时会优先从应用本地路径下(<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-built_in">data</span><span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-built_in">data</span><span class="hljs-string">``</span>/<span class="hljs-string">``</span>$&#123;package<span class="hljs-string">``</span>-<span class="hljs-string">``</span>name&#125;<span class="hljs-string">``</span>/<span class="hljs-string">``</span>lib<span class="hljs-string">``</span>/<span class="hljs-string">``</span>arm<span class="hljs-string">``</span>/<span class="hljs-string">``</span>)进行查找，不存在的话才会从系统lib路径下(<span class="hljs-string">``</span>/<span class="hljs-string">``</span>system<span class="hljs-string">``</span>/<span class="hljs-string">``</span>lib、<span class="hljs-string">``</span>/<span class="hljs-string">``</span>vendor<span class="hljs-string">``</span>/<span class="hljs-string">``</span>lib等)进行查找；而load则没有路径查找的过程<span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">3</span><span class="hljs-string">``</span>）load传入的不能是sdcard路径，会导致加载失败，一般只支持应用本地存储路径<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-built_in">data</span><span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-built_in">data</span><span class="hljs-string">``</span>/<span class="hljs-string">``</span>$&#123;package<span class="hljs-string">``</span>-<span class="hljs-string">``</span>name&#125;<span class="hljs-string">``</span>/<span class="hljs-string">``</span>，或者是系统lib路径system<span class="hljs-string">``</span>/<span class="hljs-string">``</span>lib等这<span class="hljs-string">``</span><span class="hljs-number">2</span><span class="hljs-string">``</span>类路径<span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">4</span><span class="hljs-string">``</span>）loadLibrary加载的都是一开始就已经打包进apk或系统的so文件了，而load可以是一开始就打包进来的so文件，也可以是后续从网络下载，外部导入的so文件<span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">5</span><span class="hljs-string">``</span>）重复调用loadLibrar,load并不会重复加载so，会优先从已加载的缓存中读取，所以只会加载一次<span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">6</span><span class="hljs-string">``</span>）加载成功后会去搜索so是否有<span class="hljs-string">``</span><span class="hljs-string">&quot;JNI_OnLoad&quot;</span><span class="hljs-string">``</span>，有的话则进行调用，所以<span class="hljs-string">``</span><span class="hljs-string">&quot;JNI_OnLoad&quot;</span><span class="hljs-string">``</span>只会在加载成功后被主动回调一次，一般可以用来做一些初始化的操作，比如动态注册jni相关方法等<br></code></pre></td></tr></table></figure><p>显示详细信息</p><p><strong>源码分析：</strong></p><p><strong>Android 6.0：</strong></p><p>[System.java] java.lang.System:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-string">``</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">load</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> pathName</span>) &#123;<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-title class_">Runtime</span>.<span class="hljs-title function_">getRuntime</span>().<span class="hljs-title function_">load</span>(pathName, <span class="hljs-title class_">VMStack</span>.<span class="hljs-title function_">getCallingClassLoader</span>());<span class="hljs-string">``</span>  <span class="hljs-string">``</span>&#125;<span class="hljs-string">` `</span>  <span class="hljs-string">``</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">loadLibrary</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> libName</span>) &#123;<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-title class_">Runtime</span>.<span class="hljs-title function_">getRuntime</span>().<span class="hljs-title function_">loadLibrary</span>(libName, <span class="hljs-title class_">VMStack</span>.<span class="hljs-title function_">getCallingClassLoader</span>());<span class="hljs-string">``</span>&#125;<br></code></pre></td></tr></table></figure><p>[Runtime.java] java.lang.Runtime:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-built_in">void</span> <span class="hljs-title function_">load</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> absolutePath, ClassLoader loader</span>) &#123;<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-keyword">if</span><span class="hljs-string">` `</span>(absolutePath <span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-literal">null</span>) &#123;<span class="hljs-string">``</span>      <span class="hljs-string">``</span><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">``</span><span class="hljs-string">&quot;absolutePath == null&quot;</span><span class="hljs-string">``</span>);<span class="hljs-string">``</span>    <span class="hljs-string">``</span>&#125;<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-title class_">String</span> error <span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-title function_">doLoad</span>(absolutePath, loader);<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-keyword">if</span><span class="hljs-string">` `</span>(error !<span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-literal">null</span>) &#123;<span class="hljs-string">``</span>      <span class="hljs-string">``</span><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsatisfiedLinkError</span>(error);<span class="hljs-string">``</span>    <span class="hljs-string">``</span>&#125;<span class="hljs-string">``</span>  <span class="hljs-string">``</span>&#125;<span class="hljs-string">``</span><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">loadLibrary</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> nickname</span>) &#123;<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-title function_">loadLibrary</span>(nickname, <span class="hljs-title class_">VMStack</span>.<span class="hljs-title function_">getCallingClassLoader</span>());<span class="hljs-string">``</span>  <span class="hljs-string">``</span>&#125;<span class="hljs-string">` `</span><span class="hljs-built_in">void</span> <span class="hljs-title function_">loadLibrary</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> libraryName, ClassLoader loader</span>) &#123;<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-keyword">if</span><span class="hljs-string">` `</span>(loader !<span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-literal">null</span>) &#123;<span class="hljs-string">``</span>      <span class="hljs-string">``</span><span class="hljs-title class_">String</span> filename <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>loader.<span class="hljs-title function_">findLibrary</span>(libraryName);<span class="hljs-string">``</span>      <span class="hljs-string">``</span><span class="hljs-keyword">if</span><span class="hljs-string">` `</span>(filename <span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-literal">null</span>) &#123;...<br></code></pre></td></tr></table></figure><p>显示详细信息</p><p>我们对比了Android6.0下的System.load和System.loadLibrary:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">我们可以发现<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>load<span class="hljs-constructor">Library()</span>中会修改类加载器，这个在我们后面hook过程可能会报错，而<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Runtime</span>.</span></span>load<span class="hljs-constructor">Libray()</span>中有重写的方法，则可以正确实现<br></code></pre></td></tr></table></figure><p><strong>Android 7.0：</strong></p><p>[System.java] java.lang.System:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">load</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> filename</span>) &#123;<span class="hljs-string">``</span>   <span class="hljs-string">``</span><span class="hljs-title class_">Runtime</span>.<span class="hljs-title function_">getRuntime</span>().<span class="hljs-title function_">load0</span>(<span class="hljs-title class_">VMStack</span>.<span class="hljs-title function_">getStackClass1</span>(), filename);<span class="hljs-string">``</span> <span class="hljs-string">``</span>&#125;<span class="hljs-string">` `</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">loadLibrary</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> libname</span>) &#123;<span class="hljs-string">``</span>   <span class="hljs-string">``</span><span class="hljs-title class_">Runtime</span>.<span class="hljs-title function_">getRuntime</span>().<span class="hljs-title function_">loadLibrary0</span>(<span class="hljs-title class_">VMStack</span>.<span class="hljs-title function_">getCallingClassLoader</span>(), libname);<span class="hljs-string">``</span> <span class="hljs-string">``</span>&#125;<br></code></pre></td></tr></table></figure><p>[Runtime.java] java.lang.Runtime:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript">synchronized <span class="hljs-built_in">void</span> <span class="hljs-title function_">load0</span>(<span class="hljs-params">Class fromClass, <span class="hljs-built_in">String</span> filename</span>) &#123;<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-keyword">if</span><span class="hljs-string">` `</span>(!(<span class="hljs-keyword">new</span> <span class="hljs-string">``</span><span class="hljs-title class_">File</span><span class="hljs-string">``</span>(filename).<span class="hljs-title function_">isAbsolute</span>())) &#123;<span class="hljs-string">``</span>      <span class="hljs-string">``</span><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsatisfiedLinkError</span>(<span class="hljs-string">``</span>        <span class="hljs-string">``</span><span class="hljs-string">&quot;Expecting an absolute path of the library: &quot;</span><span class="hljs-string">` `</span>+<span class="hljs-string">` `</span>filename);    &#125;<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-keyword">if</span><span class="hljs-string">` `</span>(filename <span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-literal">null</span>) &#123;<span class="hljs-string">``</span>      <span class="hljs-string">``</span><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">``</span><span class="hljs-string">&quot;filename == null&quot;</span><span class="hljs-string">``</span>);<span class="hljs-string">``</span>    <span class="hljs-string">``</span>&#125;<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-title class_">String</span> error <span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-title function_">doLoad</span>(filename, fromClass.<span class="hljs-title function_">getClassLoader</span>());<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-keyword">if</span><span class="hljs-string">` `</span>(error !<span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-literal">null</span>) &#123;<span class="hljs-string">``</span>      <span class="hljs-string">``</span><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsatisfiedLinkError</span>(error);<span class="hljs-string">``</span>    <span class="hljs-string">``</span>&#125;<span class="hljs-string">``</span>  <span class="hljs-string">``</span>&#125;<span class="hljs-string">` `</span>  <span class="hljs-string">``</span><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">loadLibrary</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> libname, ClassLoader classLoader</span>) &#123;<span class="hljs-string">``</span>    <span class="hljs-string">``</span>java.<span class="hljs-property">lang</span>.<span class="hljs-property">System</span>.<span class="hljs-title function_">logE</span>(<span class="hljs-string">``</span><span class="hljs-string">&quot;java.lang.Runtime#loadLibrary(String, ClassLoader)&quot;</span><span class="hljs-string">` `</span>+<span class="hljs-string">``</span>               <span class="hljs-string">``</span><span class="hljs-string">&quot; is private and will be removed in a future Android release&quot;</span><span class="hljs-string">``</span>);<span class="hljs-string">``</span>   <span class="hljs-string">``</span><span class="hljs-title function_">loadLibrary0</span>(classLoader, libname);<span class="hljs-string">``</span>  <span class="hljs-string">``</span>&#125;<br></code></pre></td></tr></table></figure><p>显示详细信息</p><p>我们可以发现不同版本的区别：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Android</span> ``<span class="hljs-number">6</span>.<span class="hljs-number">0</span>``采用的是loadLibrary,``<span class="hljs-number">6</span>.<span class="hljs-number">0</span>``之后都采用的是loadLibrary0; 同理 load函数也一样,``<span class="hljs-number">6</span>.<span class="hljs-number">0</span>``之后采用的是load0<br></code></pre></td></tr></table></figure><p>同时我们分析了loadLibrary0：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-number">1</span>.` `classLoader存在时，通过classLoader.findLibrary(libraryName)来获取存放指定so文件的路径；``<span class="hljs-number">2</span>.` `classLoader不存在时，则通过getLibPaths()接口来获取``<span class="hljs-number">3</span>.` `最终调用nativeLoad加载指定路径的so文件<br></code></pre></td></tr></table></figure><h2 id="四、各类hook技术原理分析"><a href="#四、各类hook技术原理分析" class="headerlink" title="四、各类hook技术原理分析"></a>四、各类hook技术原理分析</h2><p>hook技术就是指截获进程对某个API函数的调用，使得API的执行流程转向我们实现的代码片段，从而实现我们要的功能，在Android中使用hook的方法有很多，常用的Xposed和frida hook技术、inlinehook技术、基于inlinehook的开源框架Sandhook、PLT&#x2F;Got hook技术、以及当下模拟cpu的Unicorn的hook技术，下面我们将逐一介绍其原理。</p><h3 id="1-Xposed-hook技术"><a href="#1-Xposed-hook技术" class="headerlink" title="1.Xposed hook技术"></a>1.Xposed hook技术</h3><p>Xposed的基本原理，我在<a href="https://bbs.pediy.com/thread-269627.htm">源码编译（3）——Xposed框架定制</a>中已经给大家做了详细的讲解，其主要就是Android应用进程都是由 zygote 进程孵化而来，zygote对应的可执行程序就是app_process,posed 框架通过替换系统的 app_process 可执行文件以及虚拟机动态链接库，让 zygote 在启动应用程序进程时注入框架代码，进而实现对应用程序进程的劫持。</p><p>具体怎么实现hook技术，Xposed就是通过修改了Art虚拟机，将需要hook的函数注册为Native函数，当执行这一函数时，虚拟机会优先执行Native函数，然后执行java函数，这样就成功完成了函数的hook。</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_A6M5RGRCQ2A3HGM.png" alt="image-20210919155021588"></p><p>具体实现流程:</p><p>在 Android 系统启动的时候， zygote 进程加载 XposedBridge 将所有需要替换的 Method 通过 JNI 方法 hookMethodNative 指向 Native 方法 xposedCallHandler ， xposedCallHandler 在转入 handleHookedMethod 这个 Java 方法执行用户规定的 Hook Func</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_TTUBVG5KA7YWR9W.png" alt="image-20220517133042720"></p><p>dvmCallMethodV会根据accessFlags决定调用native还是java函数，因此修改accessFlags后，Dalvik会认为这个函数是一个native函数，便走向了native分支也就是说Xposed在对java方法进行hook时，先将虚拟机里面这个方法的Method的accessFlag改为native对应的值，然后将该方法的nativeFunc指向自己实现的一个native方法，这样方法在调用时，就会调用到这个native方法，接管了控制权</p><p>其他的就详细参考上篇文章了</p><h3 id="2-Frida-hook技术"><a href="#2-Frida-hook技术" class="headerlink" title="2.Frida hook技术"></a>2.Frida hook技术</h3><p>frida 也是一种动态插桩工具，原理和Xposed hook一样，也是把java method转为native method，但是Art下的实现与Dalivk有所不同，这里就需要了解ART的运行机制，这里主要参考博客：<a href="https://mabin004.github.io/2018/07/31/Mac%E4%B8%8A%E7%BC%96%E8%AF%91Frida/">Frida源码分析</a></p><p>ART 是一种代替 Dalivk 的新的运行时,它具有更高的执行效率。ART虚拟机执行 Java 方法主要有两种模式：quick code 模式和 Interpreter 模式</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">quick</span> <span class="hljs-meta">code</span> 模式：执行 <span class="hljs-meta">arm</span> 汇编指令``Interpreter 模式：由解释器解释执行 Dalvik 字节码<br></code></pre></td></tr></table></figure><p>即使是在quick code模式中，也有类方法可能需要以Interpreter模式执行。反之亦然。解释执行的类方法通过函数artInterpreterToCompiledCodeBridge的返回值调用本地机器指令执行的类方法；本地机器指令执行的类方法通过函数GetQuickToInterpreterBridge的返回值调用解释执行的类方法</p><p>这里引用博客中的一张图</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_VJRV8CFKFQS475P.png" alt="image-20220517133042720"></p><p>如图，对于一个native方法，ART虚拟机会先尝试使用quickcode的模式去执行，并检查ARTMethod结构中的entry_point_from_quick_compiled<em>code</em>成员，这里分3种情况：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-number">1</span>.``如果函数已经存在<span class="hljs-keyword">quick</span> code, 则指向这个函数对应的 <span class="hljs-keyword">quick</span> code的起始地址，而当<span class="hljs-keyword">quick</span> code不存在时，它的值则会代表其他的意义；``<span class="hljs-number">2</span>.``当一个 java 函数不存在 <span class="hljs-keyword">quick</span> code时，它的值是函数 artQuickToInterpreterBridge 的地址，用以从 <span class="hljs-keyword">quick</span> 模式切换到 Interpreter 模式来解释执行 java 函数代码；``<span class="hljs-number">3</span>.``当一个 java native（JNI）函数不存在 <span class="hljs-keyword">quick</span> code时，它的值是函数 art_quick_generic_jni_trampoline 的地址，用以执行没有<span class="hljs-keyword">quick</span> code的 jni 函数<br></code></pre></td></tr></table></figure><p>因此，frida将一个java method修改jni mthod 显然是不存在quick code，这时需要将entry_point_from_quick_compiled<em>code</em>值修改为art_quick_generic_jni_trampoline 的地址</p><p>总结，frida把java method改为jni method，需要修改ARTMethod结构体中的这几个值：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">accessflags ``=` `native``entry_point_fromjni ``=` `自定义代码的入口``entry_point_from_quick_compiledcode ``=` `art_quick_generic_jni_trampoline函数的地址``entry_point_frominterpreter ``=` `artInterpreterToCompiledCodeBridge函数地址<br></code></pre></td></tr></table></figure><h3 id="3-inlinehook-技术"><a href="#3-inlinehook-技术" class="headerlink" title="3.inlinehook 技术"></a>3.inlinehook 技术</h3><h4 id="（1）基本原理"><a href="#（1）基本原理" class="headerlink" title="（1）基本原理"></a>（1）基本原理</h4><p>首先，我们先介绍一下什么是inline Hook:</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">inline</span> Hook是一种拦截目标函数调用的方法，主要用于杀毒软件、沙箱和恶意软件。一般的想法是将一个函数重定向到我们自己的函数，以便我们可以在函数执行它之前和<span class="hljs-string">``</span>/<span class="hljs-string">``</span>或之后执行处理；这可能包括：检查参数、填充、记录、欺骗返回的数据和过滤调用。<span class="hljs-string">``</span>hook是通过直接修改目标函数内的代码来放置，通常是用跳转覆盖的前几个字节，允许在函数进行任何处理之前重定向执行。<br></code></pre></td></tr></table></figure><h4 id="（2）inlineHook组成"><a href="#（2）inlineHook组成" class="headerlink" title="（2）inlineHook组成"></a>（2）inlineHook组成</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">hook:一个<span class="hljs-string">``</span><span class="hljs-number">5</span><span class="hljs-string">``</span>字节的相对跳转，在被写入目标函数以钩住它，跳转将从被钩住的函数跳转到我们的代码<span class="hljs-string">``</span>proxy:这是我们指定的函数（或代码），放置在目标函数上的钩子将跳转到该函数（或代码）<span class="hljs-string">``</span>Trampoline:用于绕过钩子，以便我们可以正常调用钩子函数<br></code></pre></td></tr></table></figure><h4 id="（3）inlineHook实现"><a href="#（3）inlineHook实现" class="headerlink" title="（3）inlineHook实现"></a>（3）inlineHook实现</h4><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_CQY5DDQWTKHP3WS.png" alt="image-20210918161352124"></p><p>从示意图上，我们可以这样理解：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">我们将目标函数<span class="hljs-built_in">MessgeBoxA</span>()中的地址拿出来，然后我们用重写的hook函数替换，然后我们执行完成之后，再回调到函数的执行地址出，保证程序的正常运行<br></code></pre></td></tr></table></figure><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_JXZH5VUZP7ETYGZ.png" alt="image-20210919152200104"></p><p>我们也可以通过上述示意图去理解inlinehook的基本原理</p><h4 id="（4）Android-Inline-Hook和SandHook-技术"><a href="#（4）Android-Inline-Hook和SandHook-技术" class="headerlink" title="（4）Android-Inline-Hook和SandHook 技术"></a>（4）Android-Inline-Hook和SandHook 技术</h4><p>Android-lnline-Hook和SandHook都是基于inlinehook的两种开源框架，在Android中对native层hook，使用的比较常见，前者主要针对32位进行hook，后者即可以用于32位也可以用于64位，但是官方表示32位并未进行测试，所以应用在64位上仍然更多</p><h3 id="4-PLT-GOT-hook技术"><a href="#4-PLT-GOT-hook技术" class="headerlink" title="4.PLT&#x2F;GOT hook技术"></a>4.PLT&#x2F;GOT hook技术</h3><p>前面我们已经很详细的讲述了全局偏移表（GOT）和动态链接表（PLT）,Inline Hook能Hook几乎所有函数，但是兼容性较差，不能达到上线标准,相比于inlineHook，GOT Hook兼容性比较好，可以达到上线标准，但是只能Hook基于GOT表的一些函数</p><p>GOT&#x2F;PLT Hook 主要是通过解析SO文件，将待hook函数在got表的地址替换为自己函数的入口地址，这样目标进程每次调用待hook函数时，实际上是执行了我们自己的函数</p><p>这里我们还要理解GOT表中含包含了导入表和导出表</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">导出表指将当前动态库的一些函数符号保留，供外部调用<span class="hljs-string">``</span>导入表中的函数实际是在该动态库中调用外部的导出函数<br></code></pre></td></tr></table></figure><p>例如导入表存放的是一些其他so的函数，例如libc的open，而导出表存放的是一些共其他so调用的函数，比如自己so中编写的函数，而无论导入表还是导出表基本都是针对导出函数，针对非导出函用inlinehook更常用一些</p><h3 id="5-Unicorn-hook技术"><a href="#5-Unicorn-hook技术" class="headerlink" title="5.Unicorn hook技术"></a>5.Unicorn hook技术</h3><p>Unicore是一款非常优秀的跨平台模拟执行框架，该框架可以跨平台执行Arm, Arm64 (Armv8), M68K, Mips, Sparc, &amp; X86 (include X86_64)等指令集的原生程序，通过模拟CPU，可以实现很多强大的功能，也可以实现函数级别的Hook</p><p>参考资料：无名大佬文章<a href="https://bbs.pediy.com/thread-253868.htm#msg_header_h1_7">Unicorn 在 Android 的应用</a></p><p>nicorn 内部并没有函数的概念，它只是一个单纯的CPU， 没有HOOK_FUNCTION的callback，AndroidNativeEmu 中的函数级Hook 并不是真正意义上的Hook，它不仅能Hook存在的函数，还能Hook不存在的函数。AndroidNativeEmu 使用这种技术实现了JNI函数Hook、库函数Hook。 Jni函数是不存的，Hook它只是为了能够用Python 实现 Jni Functions。有一些库函数是存在的，Hook只是为了重新实现它</p><h2 id="五、各类hook技术实操"><a href="#五、各类hook技术实操" class="headerlink" title="五、各类hook技术实操"></a>五、各类hook技术实操</h2><h3 id="1-Xposed-hook实操"><a href="#1-Xposed-hook实操" class="headerlink" title="1.Xposed hook实操"></a>1.Xposed hook实操</h3><h4 id="（1）环境安装"><a href="#（1）环境安装" class="headerlink" title="（1）环境安装"></a>（1）环境安装</h4><p>Xposed环境安装详细可以参考我写的Xposed系列文章，这里只是简单的总结一下：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">(<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>) <span class="hljs-string">``</span><span class="hljs-number">4.4</span><span class="hljs-string">``</span>以下Android版本安装比较简单，只需要两步即可<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-number">1.</span><span class="hljs-string">``</span>对需要安装Xposed的手机进行root<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-number">2.</span><span class="hljs-string">``</span>下载并安装xposedInstaller,之后授权其root权限，进入app点击安装即可<span class="hljs-string">``</span>  <span class="hljs-string">``</span>但是由于官网不在维护，导致无法直接通过xposedinstaller下载补丁包<span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">2</span><span class="hljs-string">``</span>）Android <span class="hljs-string">``</span><span class="hljs-number">5.0</span><span class="hljs-string">``</span>-<span class="hljs-string">``</span><span class="hljs-number">8.0</span><span class="hljs-string">` `</span>由于<span class="hljs-string">``</span><span class="hljs-number">5.0</span><span class="hljs-string">``</span>后出现ART，所以安装步骤分成两个部分：xposed.<span class="hljs-string">``</span>zip<span class="hljs-string">` `</span>和<span class="hljs-string">``</span>  <span class="hljs-string">``</span>XposedInstaller.apk,<span class="hljs-string">``</span>zip<span class="hljs-string">``</span>文件是框架主体，需要进入Recovery后刷入，apk文件用于Xposed管理<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-number">1.</span><span class="hljs-string">``</span>完成对手机的root，并刷入reconvery(比如twrp),使用Superroot<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-number">2.</span><span class="hljs-string">``</span>下载你对应的<span class="hljs-string">``</span>zip<span class="hljs-string">``</span>补丁包，并进入recovery刷入<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-number">3.</span><span class="hljs-string">``</span>重启手机，安装xposedInstaller并授予root权限即可<span class="hljs-string">``</span>  <span class="hljs-string">``</span>官网地址：https:<span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>dl<span class="hljs-string">``</span>-<span class="hljs-string">``</span>xda.xposed.info<span class="hljs-string">``</span>/<span class="hljs-string">``</span>framework<span class="hljs-string">``</span>/<span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">3</span><span class="hljs-string">``</span>）由于Android <span class="hljs-string">``</span><span class="hljs-number">8.0</span><span class="hljs-string">``</span>后，Xposed官方作者没有再对其更新，我们一般就使用国内大佬riyu的Edxposed框架<span class="hljs-string">``</span>  <span class="hljs-string">``</span>Magisk <span class="hljs-string">``</span>+<span class="hljs-string">` `</span>riyu <span class="hljs-string">``</span>+<span class="hljs-string">` `</span>Edxposed<br></code></pre></td></tr></table></figure><p>显示详细信息</p><p>这里我们用的是nexus5进行操作，简单演示一下android6.0的Xposed安装</p><p>资源准备：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs d">asop镜像：https:<span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``d</span>evelopers.google.com<span class="hljs-string">``</span>/<span class="hljs-string">``</span>android<span class="hljs-string">``</span>/<span class="hljs-string">``</span>ota<span class="hljs-string">``</span>#hammerhead<span class="hljs-string">``</span>twrp:   https:<span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>twrp.me<span class="hljs-string">``</span>/<span class="hljs-string">``</span>xposed:  https:<span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``d</span>l<span class="hljs-string">``</span>-<span class="hljs-string">``</span>xda.xposed.info<span class="hljs-string">``</span>/<span class="hljs-string">``</span>framework<span class="hljs-string">``</span>/<span class="hljs-string">``</span>xposed installer https:<span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>repo.xposed.info<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-keyword">module</span><span class="hljs-string">``</span>/<span class="hljs-string">``d</span>e.robv.android.xposed.installer<br></code></pre></td></tr></table></figure><p>首先我们先下载n5镜像，然后刷机，这里我们已经安装就不再安装了</p><p>然后我们刷入 twrp-3.4.0-0-hammerhead.img</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">fastboot flash recovery twrp<span class="hljs-string">``</span>-<span class="hljs-string">``</span><span class="hljs-number">3.4</span><span class="hljs-string">``</span>.<span class="hljs-string">``</span><span class="hljs-number">0</span><span class="hljs-string">``</span>-<span class="hljs-string">``</span><span class="hljs-number">0</span><span class="hljs-string">``</span>-<span class="hljs-string">``</span>hammerhead.img<br></code></pre></td></tr></table></figure><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_PTP5YTG7G8Q65Q4.png" alt="image-20210919152200104"></p><p>然后我们就可以进入recovery模式了</p><p>然后我们将Supersu拷贝进去，然后将Xposed-v89-sdk.zip拷贝进去</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_USKZ6Q73UJ67BPY.png" alt="image-20210919152200104"></p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_BP8GCDGXX6RTWRZ.png" alt="image-20210919152200104"></p><p>然后我们进入recovery模式，将两个文件依次刷入即可</p><p>接下来我们安装XposedInstall.apk,来管理Xposed</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_5Y7BXVDNRSNAVR6.png" alt="image-20210919152200104"></p><p>如果我们开机后发现xposed框架没有激活，尝试再重启一下，我们可以看见</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_XNTNEVPKZK7HMWR.png" alt="image-20210919152200104"></p><p>这样我们的Xposed框架就成功安装了</p><h4 id="（2）Xposed插件编写"><a href="#（2）Xposed插件编写" class="headerlink" title="（2）Xposed插件编写"></a>（2）Xposed插件编写</h4><p>Xposed插件编写的流程网上已经有很多了，这里我就简单的讲解一下</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">基本流程：<span class="hljs-string">``</span>  <span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>)拷贝XposedBridgeApi.jar到新建工程的libs目录<span class="hljs-string">``</span>  <span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-number">2</span><span class="hljs-string">``</span>)修改app目录下的build.gradle文件，在AndroidManifest.<span class="hljs-built_in">xml</span>中增加Xposed相关内容<span class="hljs-string">``</span>  <span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-number">3</span><span class="hljs-string">``</span>)新建hook类，编写hook代码<span class="hljs-string">``</span>  <span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-number">4</span><span class="hljs-string">``</span>)新建assets文件夹，然后在assets目录下新建文件xposed_init,在里面写上hook类的完整路径<br></code></pre></td></tr></table></figure><p>首先，我们查找XposedBridgeApi.jar到新建工程的libs目录：</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_XSP2C2T7ZFRNP8G.png" alt="image-20210919152200104"></p><p>然后，修改AndroidManifest.xml文件，在Application标签下增加内容如下：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">&lt;meta<span class="hljs-string">``</span>-<span class="hljs-string">``</span><span class="hljs-built_in">data</span><span class="hljs-string">``</span>  <span class="hljs-string">``</span>android:name<span class="hljs-string">``</span>=<span class="hljs-string">``</span><span class="hljs-string">&quot;xposedmodule&quot;</span><span class="hljs-string">`  `</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>是否配置为Xposed插件，设置为<span class="hljs-literal">true</span><span class="hljs-string">``</span>  <span class="hljs-string">``</span>android:value<span class="hljs-string">``</span>=<span class="hljs-string">``</span><span class="hljs-string">&quot;true&quot;</span><span class="hljs-string">``</span>/<span class="hljs-string">``</span>&gt;<span class="hljs-string">``</span>&lt;meta<span class="hljs-string">``</span>-<span class="hljs-string">``</span><span class="hljs-built_in">data</span><span class="hljs-string">``</span>  <span class="hljs-string">``</span>android:name<span class="hljs-string">``</span>=<span class="hljs-string">``</span><span class="hljs-string">&quot;xposeddescription&quot;</span><span class="hljs-string">`  `</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>模块名称<span class="hljs-string">``</span>  <span class="hljs-string">``</span>android:value<span class="hljs-string">``</span>=<span class="hljs-string">``</span><span class="hljs-string">&quot;模块描述&quot;</span><span class="hljs-string">``</span>/<span class="hljs-string">``</span>&gt;<span class="hljs-string">``</span>&lt;meta<span class="hljs-string">``</span>-<span class="hljs-string">``</span><span class="hljs-built_in">data</span><span class="hljs-string">``</span>  <span class="hljs-string">``</span>android:name<span class="hljs-string">``</span>=<span class="hljs-string">``</span><span class="hljs-string">&quot;xposedminversion&quot;</span><span class="hljs-string">`  `</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>最低版本号<span class="hljs-string">``</span>  <span class="hljs-string">``</span>android:value<span class="hljs-string">``</span>=<span class="hljs-string">``</span><span class="hljs-string">&quot;54&quot;</span><span class="hljs-string">``</span>/<span class="hljs-string">``</span>&gt;<br></code></pre></td></tr></table></figure><p>修改app目录下的build.gradle文件：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">进入app目录下的build.gradle文件，  <span class="hljs-string">``</span>  <span class="hljs-string">``</span>compile<span class="hljs-string">` `</span>fileTree(<span class="hljs-built_in">includes</span>:[<span class="hljs-string">``</span><span class="hljs-string">&#x27;*.jar&#x27;</span><span class="hljs-string">``</span>],<span class="hljs-string">``</span>dir<span class="hljs-string">``</span>:<span class="hljs-string">``</span><span class="hljs-string">&#x27;libs&#x27;</span><span class="hljs-string">``</span>)<span class="hljs-string">``</span>  <span class="hljs-string">``</span>替换成<span class="hljs-string">``</span>  <span class="hljs-string">``</span>provided fileTree(<span class="hljs-built_in">includes</span>:[<span class="hljs-string">``</span><span class="hljs-string">&#x27;*.jar&#x27;</span><span class="hljs-string">``</span>],<span class="hljs-string">``</span>dir<span class="hljs-string">``</span>:<span class="hljs-string">``</span><span class="hljs-string">&#x27;libs&#x27;</span><span class="hljs-string">``</span>)<span class="hljs-string">``</span>现在provided变为 compileOnly<span class="hljs-string">``</span>如果使用<span class="hljs-string">``</span>compile<span class="hljs-string">``</span>,可以正常编译生成插件apk,但是当安装到手机上后，xposed会报错，无法正常工作<br></code></pre></td></tr></table></figure><p>编写hook类：</p><p>我们新建一个hook类xposed01，并实现接口IXposedHookLoadPackage,并实现里面关键方法handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam)，该方法会在每个软件被启动的时候回调，所以一般需要通过目标包名过滤</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">public</span> <span class="hljs-string">``</span>class<span class="hljs-string">` `</span>Xposed01 implements IXposedHookLoadPackage &#123;<span class="hljs-string">` `</span>  <span class="hljs-string">``</span>@Override<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable &#123;<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-keyword">if</span><span class="hljs-string">``</span>(loadPackageParam.packageName.<span class="hljs-keyword">equals</span>(<span class="hljs-string">``</span><span class="hljs-string">&quot;com.example.xposedlesson2&quot;</span><span class="hljs-string">``</span>))&#123; <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>判断目标包名<span class="hljs-string">``</span>      <span class="hljs-string">``</span>XposedBridge.<span class="hljs-keyword">log</span>(<span class="hljs-string">``</span><span class="hljs-string">&quot;XLZH&quot;</span><span class="hljs-string">``</span>+<span class="hljs-string">``</span>loadPackageParam.packageName); <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>打出包名的信息<span class="hljs-string">``</span>      <span class="hljs-string">``</span><span class="hljs-keyword">Log</span>.i(<span class="hljs-string">``</span><span class="hljs-string">&quot;Xposed01&quot;</span><span class="hljs-string">``</span>,loadPackageParam.packageName);<span class="hljs-string">``</span>    <span class="hljs-string">``</span>&#125;<span class="hljs-string">``</span>  <span class="hljs-string">``</span>&#125;<span class="hljs-string">``</span>&#125;<br></code></pre></td></tr></table></figure><p>显示详细信息</p><p>新建assets文件夹，然后在assets目录下新建文件xposed_init,在里面写上hook类的完整路径</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_M8K7JKCWGJZM2C7.png" alt="image-20210919152200104"></p><p>这里面可以写多个hook类，每个类写一个，我们就完成了基本的Xposed框架的编写</p><p>最后勾选模块，并重启即可生效</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_K8KRQA95GC2T55T.png" alt="image-20210919152200104"></p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_WYH6S62TQ4H4W69.png" alt="image-20210919152200104"></p><p>我们可以发现我们的xposed插件生效了，将我们系统中进程名打印出来了,说明hook成功了</p><h3 id="2-frida-hook实操"><a href="#2-frida-hook实操" class="headerlink" title="2.frida hook实操"></a>2.frida hook实操</h3><h4 id="（1）环境安装-1"><a href="#（1）环境安装-1" class="headerlink" title="（1）环境安装"></a>（1）环境安装</h4><p>frida安装，使用frida过程中我们可以安装objection来进一步助力我们的hook工作，这个参考肉丝大佬的知识星球</p><p>工具安装（也可以选用其他版本）：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">pip install frida<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span><span class="hljs-number">12.8</span><span class="hljs-string">``</span>.<span class="hljs-string">``</span><span class="hljs-number">0</span><span class="hljs-string">``</span>pip install frida<span class="hljs-string">``</span>-<span class="hljs-string">``</span>tools<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span><span class="hljs-number">5.3</span><span class="hljs-string">``</span>.<span class="hljs-string">``</span><span class="hljs-number">0</span><span class="hljs-string">``</span>pip install objection<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span><span class="hljs-number">1.8</span><span class="hljs-string">``</span>.<span class="hljs-string">``</span><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>安装成功后，查看frida和objection，确定版本正确</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs d">frida <span class="hljs-string">``</span>-<span class="hljs-string">``</span>-<span class="hljs-string">``</span><span class="hljs-keyword">version</span><span class="hljs-string">``</span>objection <span class="hljs-string">``</span>-<span class="hljs-string">``</span>-<span class="hljs-string">``</span>help<br></code></pre></td></tr></table></figure><p>然后将frida_server推送到<code>/data/local/tmp</code>下，并启动：（下载地址：<a href="https://github.com/frida/frida/releases%EF%BC%89">https://github.com/frida/frida/releases）</a></p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_DK5Z49RCDWTK5V7.png" alt="image-20220517153822302"></p><h4 id="（2）frida使用"><a href="#（2）frida使用" class="headerlink" title="（2）frida使用"></a>（2）frida使用</h4><p>然后我们就可以使用自动化工具objection和编写js脚本进行hook了</p><p>objection使用（详细参考肉丝大佬github的教程）：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">常见的hook命令：``objection ``-``g com.android.settings explore ``/``/``注入设置应用``android hooking ``list` `activities ``/``/``查看Activity，service相同``android intent launch_activity com.android.settings.DisplaySettings ``/``/``实现Activity跳转``android heap search instances com.android.settings.DisplaySettings  ``/``/``搜索类的实例``android heap execute ``<span class="hljs-number">0</span>x2526` `getPreferenceScreenResId  ``/``/``主动调用实例``android hooking ``list` `classes ``/``/``列出内存中所有类``android hooking search methods display ``/``/``列出内存中所有的方法``android hooking watch ``class` `android.bluetooth.BluetoothDevice ``/``/``hook相关类的所有方法``android hooking watch class_method android.bluetooth.BluetoothDevice.getName ``-``-``dump``-``args ``-``-``dump``-``<span class="hljs-keyword">return</span>` `-``-``dump``-``backtrace ``/``/``打印具体方法的参数、返回值、堆栈信息<br></code></pre></td></tr></table></figure><p>编写脚本：</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_R2F8JJFJF5PN2XU.png" alt="image-20220517154213936"></p><p>启动方式：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">attach方式 frida ``-``U com.example.test ``-``l hook.js``spwan启动 frida ``-``U ``-``f com.example.test ``-``l demo1.js ``-``-``no``-``<span class="hljs-keyword">pause</span><br></code></pre></td></tr></table></figure><p>这样我们就可以成功注入了，更加复杂的脚本编写可以参考<a href="https://github.com/hookmaster/frida-all-in-one">frida博客</a></p><p>详细案例实操，这里可以参考之前我的文章:<a href="https://bbs.pediy.com/thread-269128.htm">Android恶意样本分析——frida破解三层锁机样本</a></p><h3 id="3-inlinehook实操"><a href="#3-inlinehook实操" class="headerlink" title="3.inlinehook实操"></a>3.inlinehook实操</h3><p>这里我们分别实现基于inlinehook的两个开源框架的具体使用方法</p><h4 id="（1）Android-lnine-Hook"><a href="#（1）Android-lnine-Hook" class="headerlink" title="（1）Android-lnine-Hook"></a>（1）Android-lnine-Hook</h4><p>开源地址：<a href="https://github.com/ele7enxxh/Android-Inline-Hook">https://github.com/ele7enxxh/Android-Inline-Hook</a></p><p>该框架只能针对32位的so文件进行hook</p><p>我们对so文件进行hook时，可以按照如下步骤进行：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">（<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>）查看so文件中的目标函数<span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">2</span><span class="hljs-string">``</span>）编写Xposed hook代码，hook目标程序<span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">3</span><span class="hljs-string">``</span>）编写so层hook代码，hook so中的函数地址<span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">4</span><span class="hljs-string">``</span>）链接Java层和so层<br></code></pre></td></tr></table></figure><h5 id="编写目标函数so文件"><a href="#编写目标函数so文件" class="headerlink" title="&lt;1&gt;编写目标函数so文件"></a>&lt;1&gt;编写目标函数so文件</h5><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_5M34E5RGVMHTXVQ.png" alt="image-20220517160033161"></p><p>我们编写案例，很明显这里会打印失败，然后我们使用inline-hook框架进行hook</p><h5 id="导入文件"><a href="#导入文件" class="headerlink" title="&lt;2&gt;导入文件"></a>&lt;2&gt;导入文件</h5><p>我们将该框架中如下文件导入我们的项目中</p><p>我们需要使用<a href="https://github.com/ele7enxxh/Android-Inline-Hook">inlineHook</a>文件夹，并把这些文件直接拷贝到我们的工作目录：</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_J35447VZ396W69Y.png" alt="image-20210919152200104"></p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_PM8D54VPMM4V2DN.png" alt="image-20210919152200104"></p><h5 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="&lt;3&gt;修改配置文件"></a>&lt;3&gt;修改配置文件</h5><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_RWZAX8NBEZYBSWU.png" alt="image-20220517160824232"></p><h5 id="编写hook代码"><a href="#编写hook代码" class="headerlink" title="&lt;4&gt;编写hook代码"></a>&lt;4&gt;编写hook代码</h5><p>我们导入inlinehook头文件就可以开始编写hook代码了</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_TWS32X2EXSB6JKX.png" alt="image-20220517160918834"></p><p>编译，报错：</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_D67M5NGM8V5PBSZ.png" alt="image-20220517163117937"></p><p>这是因为框架仅仅针对32位，所以我们需要在配置文件里面指定一下</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_NXT48W65NN9ZDDC.png" alt="image-20220517163519977"></p><p>然后编译，发现能正常通过</p><p>首先声明hook的就函数，然后编写对应的新函数，这里我们hook的是<code>strstr函数</code></p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_9JHGK9T47FU4C88.png" alt="image-20220517185051670"></p><p>然后调用inlinehook进行hook</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_X56HZNKEDMKMDRW.png" alt="image-20220517185429734"></p><p>最后我们发现就可以成功的hook</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_6RH3X3BJK6HVQR6.png" alt="image-20220517185538606"></p><p>代码分析：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs d">源码解析：<span class="hljs-string">``</span>  <span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>）dlopen：该函数将打开一个新库，并把它装入内存<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-keyword">void</span> <span class="hljs-string">``</span>*<span class="hljs-string">``d</span>lopen(<span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> <span class="hljs-string">``</span>*<span class="hljs-string">``</span>filename, <span class="hljs-string">``</span><span class="hljs-keyword">int</span><span class="hljs-string">` `</span>flag);<span class="hljs-string">``</span>    <span class="hljs-string">``</span>参数<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>：文件名就是一个动态库so文件，标志位：RTLD_NOW 的话，则立刻计算；设置的是 RTLD_LAZY，则在需要的时候才计算<span class="hljs-string">``</span>    <span class="hljs-string">``</span>libc.so是一个共享库<span class="hljs-string">``</span>    <span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>    <span class="hljs-string">``</span>参数中的 libname 一般是库的全路径，这样 dlopen 会直接装载该文件；如果只是指定了库名称，在 dlopen 会按照下面的机制去搜寻：<span class="hljs-string">``</span>    <span class="hljs-string">``</span>根据环境变量 LD_LIBRARY_PATH 查找<span class="hljs-string">``</span>    <span class="hljs-string">``</span>根据 <span class="hljs-string">``</span>/<span class="hljs-string">``</span>etc<span class="hljs-string">``</span>/<span class="hljs-string">``</span>ld.so.cache 查找<span class="hljs-string">``</span>    <span class="hljs-string">``</span>查找依次在 <span class="hljs-string">``</span>/<span class="hljs-string">``</span>lib 和 <span class="hljs-string">``</span>/<span class="hljs-string">``</span>usr<span class="hljs-string">``</span>/<span class="hljs-string">``</span>lib 目录查找。<span class="hljs-string">``</span>    <span class="hljs-string">``</span>flag 参数表示处理未定义函数的方式，可以使用 RTLD_LAZY 或 RTLD_NOW 。 RTLD_LAZY 表示暂时不去处理未定义函数，先把库装载到内存，等用到没定义的函数再说； RTLD_NOW 表示马上检查是否存在未定义的函数，若存在，则 dlopen 以失败告终。<span class="hljs-string">``</span>    <span class="hljs-string">``</span>参考链接：https:<span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>blog.nowcoder.net<span class="hljs-string">``</span>/<span class="hljs-string">``</span>n<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-number">5</span>b2c04bbcccf431e9f1ab34aa02717fe<span class="hljs-string">``</span>    <span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span>  <span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">2</span><span class="hljs-string">``</span>）dlsym:在 dlopen 之后，库被装载到内存。 dlsym 可以获得指定函数( symbol )在内存中的位置(指针)。<span class="hljs-string">``</span>     <span class="hljs-string">``</span><span class="hljs-keyword">void</span> <span class="hljs-string">``</span>*<span class="hljs-string">``d</span>lsym(<span class="hljs-keyword">void</span> <span class="hljs-string">``</span>*<span class="hljs-string">``</span>handle,<span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> <span class="hljs-string">``</span>*<span class="hljs-string">``</span>symbol);<span class="hljs-string">``</span>     <span class="hljs-string">``</span>参数<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>：文件句柄 参数<span class="hljs-string">``</span><span class="hljs-number">2</span><span class="hljs-string">``</span>：函数名<br></code></pre></td></tr></table></figure><p>显示详细信息</p><p>inlinehook框架使用正确姿势：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs d">我们对一个目标so文件hook步骤如下：<span class="hljs-string">``</span>  <span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>）我们获取so的handler，使用dlopen函数<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-keyword">void</span><span class="hljs-string">``</span>*<span class="hljs-string">` `</span>libhandler <span class="hljs-string">``</span>=<span class="hljs-string">` `d</span>lopen(<span class="hljs-string">``</span><span class="hljs-string">&quot;libc.so&quot;</span><span class="hljs-string">``</span>,RTLD_NOW);<span class="hljs-string">``</span>  <span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">2</span><span class="hljs-string">``</span>）我们获取hook目标函数的地址,使用dlsym函数<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-keyword">void</span><span class="hljs-string">``</span>*<span class="hljs-string">` `</span>strstr_addr <span class="hljs-string">``</span>=<span class="hljs-string">` `d</span>lsym(libhandler,函数名);<span class="hljs-string">``</span>  <span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">3</span><span class="hljs-string">``</span>）声明原来的函数<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-keyword">void</span><span class="hljs-string">``</span>*<span class="hljs-string">` `</span>(<span class="hljs-string">``</span>*<span class="hljs-string">``</span>oldmethod)(<span class="hljs-built_in">char</span><span class="hljs-string">``</span>*<span class="hljs-string">``</span>,<span class="hljs-built_in">char</span><span class="hljs-string">``</span>*<span class="hljs-string">``</span>); <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>这个格式需要参考hook的函数<span class="hljs-string">``</span>    <span class="hljs-string">``</span>声明现在的函数<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-keyword">void</span><span class="hljs-string">``</span>*<span class="hljs-string">` `</span>newmethod(<span class="hljs-built_in">char</span><span class="hljs-string">``</span>*<span class="hljs-string">` `</span>a,<span class="hljs-built_in">char</span><span class="hljs-string">``</span>*<span class="hljs-string">` `</span>b)&#123;<span class="hljs-string">``</span>      <span class="hljs-string">``</span><span class="hljs-keyword">return</span><span class="hljs-string">` `</span>(<span class="hljs-keyword">void</span> <span class="hljs-string">``</span>*<span class="hljs-string">``</span>)oldmethod(a,b);<span class="hljs-string">``</span>    <span class="hljs-string">``</span>&#125;<span class="hljs-string">``</span>  <span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">3</span><span class="hljs-string">``</span>）使用registerInlinehook进行重定向，将hook函数地址重定向我们编写的新函数上<span class="hljs-string">``</span>    <span class="hljs-string">``</span>(registerInlineHook((uint32_t) strstr_addr, (uint32_t) new_strstr, (uint32_t <span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>) &amp;old_strstr) !<span class="hljs-string">``</span>=<span class="hljs-string">` `</span>ELE7EN_OK<span class="hljs-string">``</span>    <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>参数一：hook函数的地址 参数二：替换函数的地址 参数<span class="hljs-string">``</span><span class="hljs-number">3</span><span class="hljs-string">``</span>：用来保存原来函数的地址<span class="hljs-string">``</span>  <span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">5</span><span class="hljs-string">``</span>）我们判断我们的hook操作是否成功,并且再次调用实现hook<span class="hljs-string">``</span>    <span class="hljs-string">``</span>(inlineHook((uint32_t) strstr_addr) <span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">` `</span>ELE7EN_OK)<br></code></pre></td></tr></table></figure><p>显示详细信息</p><h4 id="（2）SandHook实操"><a href="#（2）SandHook实操" class="headerlink" title="（2）SandHook实操"></a>（2）SandHook实操</h4><p>因为上面使用inline框架只支持32位，所以这里我们用SandHook实现对64位native函数的hook，<a href="https://github.com/asLody/SandHook">sandHook</a>既支持32位、又支持64位</p><p>开源地址：<a href="https://github.com/asLody/SandHook">https://github.com/asLody/SandHook</a></p><p>同样是上面的案例，这里我们使用SandHook进行实操</p><h5 id="导入文件-1"><a href="#导入文件-1" class="headerlink" title="&lt;1&gt;导入文件"></a>&lt;1&gt;导入文件</h5><p>我们此路径下<code>SandHook/nativehook/src/main/cpp/</code>文件全部导入</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_UENG24U66ADC7WG.png" alt="image-20220517191708611"></p><h5 id="配置环境"><a href="#配置环境" class="headerlink" title="&lt;2&gt;配置环境"></a>&lt;2&gt;配置环境</h5><p>首先我们在CMakeList中加入c文件</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_K28NFSCXPDMCXZA.png" alt="image-20220517192031241"></p><p>然后在java代码中修改导入的so库</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_BKTVYYEPN7R47Z6.png" alt="image-20220517192224416"></p><p>直接编译，报错：</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_3UGDSRDEFN48UBY.png" alt="image-20220517192315719"></p><p>然后我们同理将配置信息加入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">cmake &#123;<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-variable language_">arguments</span> <span class="hljs-string">``</span><span class="hljs-string">&#x27;-DBUILD_TESTING=OFF&#x27;</span><span class="hljs-string">``</span>  <span class="hljs-string">``</span>cppFlags <span class="hljs-string">``</span><span class="hljs-string">&quot;-frtti -fexceptions -Wpointer-arith&quot;</span><span class="hljs-string">``</span>  <span class="hljs-string">``</span>abiFilters <span class="hljs-string">``</span><span class="hljs-string">&#x27;armeabi-v7a&#x27;</span><span class="hljs-string">``</span>, <span class="hljs-string">``</span><span class="hljs-string">&#x27;arm64-v8a&#x27;</span><span class="hljs-string">``</span>&#125;<br></code></pre></td></tr></table></figure><p>再次编译成功</p><h5 id="编写hook代码-1"><a href="#编写hook代码-1" class="headerlink" title="&lt;3&gt;编写hook代码"></a>&lt;3&gt;编写hook代码</h5><p>SandHook使用和上面inlinehook框架基本一样</p><p>首先声明旧的函数，编写新的函数（目标函数strstr）</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_PTP33M4B8NPEF7Y.png" alt="image-20220517193411921"></p><p>然后进行hook</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_VWARWTJFRXBE7BG.png" alt="image-20220517193556517"></p><p>最后发现可以成功hook</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_RDJ2MVC9GYJQ8M3.png" alt="image-20220517193629093"></p><p>SandHook使用姿势：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">（<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>）导包，将<span class="hljs-title class_">SandHook</span>中cpp文件夹下的包全部导入到项目中，并修改<span class="hljs-title class_">CMakeLists</span>.<span class="hljs-property">txt</span>中添加native.<span class="hljs-property">cpp</span>, 修改java层导入so库为sandHook<span class="hljs-string">``</span>-<span class="hljs-string">``</span>native<span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">2</span><span class="hljs-string">``</span>）配置相关的环境<span class="hljs-string">``</span>  <span class="hljs-string">``</span>在配置文件build.<span class="hljs-property">gradle</span>中配置<span class="hljs-string">``</span>  <span class="hljs-string">``</span>externalNativeBuild &#123;<span class="hljs-string">``</span>     <span class="hljs-string">``</span>cmake &#123;<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-variable language_">arguments</span> <span class="hljs-string">``</span><span class="hljs-string">&#x27;-DBUILD_TESTING=OFF&#x27;</span><span class="hljs-string">``</span>    <span class="hljs-string">``</span>cppFlags <span class="hljs-string">``</span><span class="hljs-string">&quot;-frtti -fexceptions -Wpointer-arith&quot;</span><span class="hljs-string">``</span>    <span class="hljs-string">``</span>abiFilters <span class="hljs-string">``</span><span class="hljs-string">&#x27;armeabi-v7a&#x27;</span><span class="hljs-string">``</span>, <span class="hljs-string">``</span><span class="hljs-string">&#x27;arm64-v8a&#x27;</span><span class="hljs-string">``</span>     <span class="hljs-string">``</span>&#125;<span class="hljs-string">``</span>    <span class="hljs-string">``</span>&#125;<span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">3</span><span class="hljs-string">``</span>）编译可以成功通过<span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">4</span><span class="hljs-string">``</span>）使用<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-keyword">const</span> char <span class="hljs-string">``</span>*<span class="hljs-string">` `</span>libc <span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-string">&quot;/system/lib64/libc.so&quot;</span><span class="hljs-string">``</span>;<span class="hljs-string">``</span>  <span class="hljs-string">``</span>old_fopen <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>reinterpret_cast&lt;<span class="hljs-keyword">void</span> <span class="hljs-string">``</span>*<span class="hljs-string">``</span>(<span class="hljs-string">``</span>*<span class="hljs-string">``</span>)(char <span class="hljs-string">``</span>*<span class="hljs-string">``</span>, char <span class="hljs-string">``</span>*<span class="hljs-string">``</span>)&gt;(<span class="hljs-title class_">SandInlineHookSym</span>(libc, <span class="hljs-string">``</span><span class="hljs-string">&quot;fopen&quot;</span><span class="hljs-string">``</span>,<span class="hljs-string">``</span>                                     <span class="hljs-string">``</span>reinterpret_cast&lt;<span class="hljs-keyword">void</span> <span class="hljs-string">``</span>*<span class="hljs-string">``</span>&gt;(new_fopen)));<span class="hljs-string">``</span>参数<span class="hljs-string">``</span><span class="hljs-number">2</span><span class="hljs-string">``</span>：hook的函数 参数<span class="hljs-string">``</span><span class="hljs-number">3</span><span class="hljs-string">``</span>：新的函数<span class="hljs-string">` `</span>添加原理hook旧函数的声明<span class="hljs-string">``</span><span class="hljs-keyword">void</span><span class="hljs-string">``</span>*<span class="hljs-string">` `</span>(<span class="hljs-string">``</span>*<span class="hljs-string">``</span>old_fopen)(char<span class="hljs-string">``</span>*<span class="hljs-string">``</span>,char<span class="hljs-string">``</span>*<span class="hljs-string">``</span>);<span class="hljs-string">``</span>实现新的函数功能<span class="hljs-string">``</span><span class="hljs-keyword">void</span><span class="hljs-string">``</span>*<span class="hljs-string">` `</span><span class="hljs-title function_">new_fopen</span>(<span class="hljs-params">char<span class="hljs-string">``</span>*<span class="hljs-string">` `</span>a,char<span class="hljs-string">``</span>*<span class="hljs-string">` `</span>b</span>)&#123;<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-title function_">__android_log_print</span>(<span class="hljs-string">``</span><span class="hljs-number">6</span><span class="hljs-string">``</span>,<span class="hljs-string">``</span><span class="hljs-string">&quot;windaa&quot;</span><span class="hljs-string">``</span>,<span class="hljs-string">``</span><span class="hljs-string">&quot;I am from new open %s&quot;</span><span class="hljs-string">``</span>,a);<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-keyword">return</span><span class="hljs-string">` `</span><span class="hljs-title function_">old_fopen</span>(a,b);<span class="hljs-string">``</span>&#125;<span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">5</span><span class="hljs-string">``</span>）运行测试是否成功启动<br></code></pre></td></tr></table></figure><p>显示详细信息</p><h3 id="4-PLT-GOT-hook实操"><a href="#4-PLT-GOT-hook实操" class="headerlink" title="4.PLT&#x2F;GOT hook实操"></a>4.PLT&#x2F;GOT hook实操</h3><p>前面我们已经介绍了Got表hook的原理，下面我们实例操作一下导入表函数的hook</p><p>参考博客：<a href="https://www.cnblogs.com/goodhacker/p/9306997.html">https://www.cnblogs.com/goodhacker/p/9306997.html</a></p><p>原理：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">通过解析elf格式，分析Section header table找出静态的<span class="hljs-string">.got</span>表的位置，并在内存中找到相应的<span class="hljs-string">.got</span>表位置，这个时候内存中<span class="hljs-string">.got</span>表保存着导入函数的地址，读取目标函数地址，与<span class="hljs-string">.got</span>表每一项函数入口地址进行匹配，找到的话就直接替换新的函数地址，这样就完成了一次导入表的Hook操作了<br></code></pre></td></tr></table></figure><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_ZQSAKZF2U7B5GNE.png" alt="image-20220517193556517"></p><p>首先，我们编写demo</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_QM94VN789TPJJTK.png" alt="image-20220517193556517"></p><p>我们编译后使用010Editor打开<code>libnative-lib.so</code></p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_EKYS5SE78TQUKNV.png" alt="image-20220517193556517"></p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_GVKDZZSTB8VBTEA.png" alt="image-20220517193556517"></p><p>然后我们用ida打开，并直接跳转到该地址</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_V3PY8VJY2TYXEEX.png" alt="image-20220517193556517"></p><p>在got表中我们找到对应的mywin0函数</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_6WBC3YU8VG6KQMG.png" alt="image-20220517193556517"></p><h5 id="获得so模块的加载地址"><a href="#获得so模块的加载地址" class="headerlink" title="&lt;1&gt;获得so模块的加载地址"></a>&lt;1&gt;获得so模块的加载地址</h5><p>我们可以使用<code>/proc/self/maps</code>去获得so模块的加载地址</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">char line[<span class="hljs-string">``</span><span class="hljs-number">1024</span><span class="hljs-string">``</span>];<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-keyword">int</span><span class="hljs-string">` `</span>*<span class="hljs-string">``</span>start;<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-keyword">int</span><span class="hljs-string">` `</span>*<span class="hljs-string">``</span>end;<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-keyword">int</span><span class="hljs-string">` `</span>n<span class="hljs-string">``</span>=<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>;<span class="hljs-string">``</span>  <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-number">1.</span><span class="hljs-string">``</span>拿到so的起始地址<span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">`  `</span><span class="hljs-number">749e5</span>d7000<span class="hljs-string">``</span>-<span class="hljs-string">``</span><span class="hljs-number">749e5</span>db000<span class="hljs-string">` `</span>r<span class="hljs-string">``</span>-<span class="hljs-string">``</span>-<span class="hljs-string">``</span>p <span class="hljs-string">``</span><span class="hljs-number">000</span>f4000<span class="hljs-string">` `</span><span class="hljs-number">103</span><span class="hljs-string">``</span>:<span class="hljs-string">``</span><span class="hljs-number">09</span><span class="hljs-string">` `</span><span class="hljs-number">441</span><span class="hljs-string">`              `</span>/<span class="hljs-string">``</span><span class="hljs-keyword">system</span><span class="hljs-string">``</span>/<span class="hljs-string">``</span>bin<span class="hljs-string">``</span>/<span class="hljs-string">``</span>linker64<span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">`  `</span><span class="hljs-number">749e5</span>db000<span class="hljs-string">``</span>-<span class="hljs-string">``</span><span class="hljs-number">749e5</span>dc000<span class="hljs-string">` `</span>rw<span class="hljs-string">``</span>-<span class="hljs-string">``</span>p <span class="hljs-string">``</span><span class="hljs-number">000</span>f8000<span class="hljs-string">` `</span><span class="hljs-number">103</span><span class="hljs-string">``</span>:<span class="hljs-string">``</span><span class="hljs-number">09</span><span class="hljs-string">` `</span><span class="hljs-number">441</span><span class="hljs-string">`              `</span>/<span class="hljs-string">``</span><span class="hljs-keyword">system</span><span class="hljs-string">``</span>/<span class="hljs-string">``</span>bin<span class="hljs-string">``</span>/<span class="hljs-string">``</span>linker64<span class="hljs-string">``</span>  <span class="hljs-string">``</span>FILE<span class="hljs-string">` `</span>*<span class="hljs-string">``</span>fd <span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-keyword">fopen</span>(<span class="hljs-string">``</span><span class="hljs-string">&quot;/proc/self/maps&quot;</span><span class="hljs-string">``</span>,<span class="hljs-string">``</span><span class="hljs-string">&quot;r&quot;</span><span class="hljs-string">``</span>);<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-keyword">while</span><span class="hljs-string">` `</span>(fgets(line,sizeof(line),fd))&#123;<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-keyword">if</span><span class="hljs-string">``</span>(strstr(line,<span class="hljs-string">``</span><span class="hljs-string">&quot;libnative-lib.so&quot;</span><span class="hljs-string">``</span>))&#123;<span class="hljs-string">``</span>      <span class="hljs-string">``</span>__android_log_print(<span class="hljs-string">``</span><span class="hljs-number">6</span><span class="hljs-string">``</span>,<span class="hljs-string">``</span><span class="hljs-string">&quot;windaa&quot;</span><span class="hljs-string">``</span>,<span class="hljs-string">``</span><span class="hljs-string">&quot;%s&quot;</span><span class="hljs-string">``</span>,line);<span class="hljs-string">``</span>      <span class="hljs-string">``</span><span class="hljs-keyword">if</span><span class="hljs-string">``</span>(n<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>)&#123;<span class="hljs-string">``</span>        <span class="hljs-string">``</span>start <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>reinterpret_cast&lt;<span class="hljs-string">``</span><span class="hljs-keyword">int</span><span class="hljs-string">` `</span>*<span class="hljs-string">``</span>&gt;(strtoul(strtok(line, <span class="hljs-string">``</span><span class="hljs-string">&quot;-&quot;</span><span class="hljs-string">``</span>),NULL,<span class="hljs-string">``</span><span class="hljs-number">16</span><span class="hljs-string">``</span>));<span class="hljs-string">``</span>        <span class="hljs-string">``</span>end <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>reinterpret_cast&lt;<span class="hljs-string">``</span><span class="hljs-keyword">int</span><span class="hljs-string">` `</span>*<span class="hljs-string">``</span>&gt;(strtoul(strtok(NULL, <span class="hljs-string">``</span><span class="hljs-string">&quot; &quot;</span><span class="hljs-string">``</span>),NULL,<span class="hljs-string">``</span><span class="hljs-number">16</span><span class="hljs-string">``</span>));<span class="hljs-string">``</span>      <span class="hljs-string">``</span>&#125;<span class="hljs-string">``</span>      <span class="hljs-string">``</span><span class="hljs-keyword">else</span><span class="hljs-string">``</span>&#123;<span class="hljs-string">``</span>        <span class="hljs-string">``</span>strtok(line,<span class="hljs-string">``</span><span class="hljs-string">&quot;-&quot;</span><span class="hljs-string">``</span>);<span class="hljs-string">``</span>        <span class="hljs-string">``</span>end <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>reinterpret_cast&lt;<span class="hljs-string">``</span><span class="hljs-keyword">int</span><span class="hljs-string">` `</span>*<span class="hljs-string">``</span>&gt;(strtoul(strtok(NULL, <span class="hljs-string">``</span><span class="hljs-string">&quot; &quot;</span><span class="hljs-string">``</span>),NULL,<span class="hljs-string">``</span><span class="hljs-number">16</span><span class="hljs-string">``</span>));<span class="hljs-string">``</span>      <span class="hljs-string">``</span>&#125;<span class="hljs-string">``</span>      <span class="hljs-string">``</span>n<span class="hljs-string">``</span>+<span class="hljs-string">``</span>+<span class="hljs-string">``</span>;<span class="hljs-string">``</span>    <span class="hljs-string">``</span>&#125;<span class="hljs-string">``</span>  <span class="hljs-string">``</span>&#125;<br></code></pre></td></tr></table></figure><p>显示详细信息</p><h5 id="找到got表的位置"><a href="#找到got表的位置" class="headerlink" title="&lt;2&gt;找到got表的位置"></a>&lt;2&gt;找到got表的位置</h5><p>我们首先根据段头找到section_header的首地址</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_Q7NVUZ5B2X57YS4.png" alt="image-20220517193556517"></p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_TVKKU6G357P3HWZ.png" alt="image-20220517193556517"></p><p>然后我们遍历这个表就可以找到.got,然后根据got表地址再轮训找到函数地址</p><p>因为这种方法不能在内存中直接找到段头，内存中会抹去段头，所以我们可以通过加载so文件来定位</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_K8TVAMSKQ6KQC6U.png" alt="image-20220517193556517"></p><h5 id="定位到节表的地址"><a href="#定位到节表的地址" class="headerlink" title="&lt;3&gt;定位到节表的地址"></a>&lt;3&gt;定位到节表的地址</h5><p>然后我们来获得节表的地址：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>读取elf文件<span class="hljs-string">``</span>  <span class="hljs-string">``</span>Elf64_Ehdr ehd;<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-keyword">int</span><span class="hljs-string">` `</span>fp <span class="hljs-string">``</span>=<span class="hljs-string">``</span><span class="hljs-keyword">open</span><span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-string">&quot;/data/local/tmp/libnative-lib.so&quot;</span><span class="hljs-string">``</span>, O_RDONLY);<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-keyword">if</span><span class="hljs-string">``</span>(fp <span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">` `</span>-<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>)&#123;<span class="hljs-string">``</span>    <span class="hljs-string">``</span>__android_log_print(<span class="hljs-string">``</span><span class="hljs-number">4</span><span class="hljs-string">``</span>,<span class="hljs-string">``</span><span class="hljs-string">&quot;windaa&quot;</span><span class="hljs-string">``</span>,<span class="hljs-string">``</span><span class="hljs-string">&quot;%s&quot;</span><span class="hljs-string">``</span>,<span class="hljs-string">``</span><span class="hljs-string">&quot;error&quot;</span><span class="hljs-string">``</span>);<span class="hljs-string">``</span>  <span class="hljs-string">``</span>&#125;<span class="hljs-string">``</span>  <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>读取elf文件的文件头<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-keyword">read</span>(fp,&amp;ehd,sizeof(Elf64_Ehdr));<span class="hljs-string">``</span>  <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>读取节表的地址<span class="hljs-string">``</span>  <span class="hljs-string">``</span>unsigned <span class="hljs-string">``</span>long<span class="hljs-string">` `</span>shof <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>ehd.e_shoff;<span class="hljs-string">``</span>  <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>读取节表的数量<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-keyword">int</span><span class="hljs-string">` `</span>shnum <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>ehd.e_shnum;<span class="hljs-string">``</span>  <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>读取每个节表的大小<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-keyword">int</span><span class="hljs-string">` `</span>shsize <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>ehd.e_ehsize;<span class="hljs-string">``</span>  <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>记录一下<span class="hljs-string">``</span>str<span class="hljs-string">``</span>表的偏移，主要是获取后面got的字符串值<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-keyword">int</span><span class="hljs-string">` `</span>shstr <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>ehd.e_shstrndx;<br></code></pre></td></tr></table></figure><p>显示详细信息</p><p>我们打印一下此事shof的值，验证一下节表的地址</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_VJRHUBSV8PK6TYC.png" alt="image-20220517193556517"></p><p>这里可以发现成功读取</p><h5 id="定位到got表的位置和函数位置"><a href="#定位到got表的位置和函数位置" class="headerlink" title="&lt;4&gt;定位到got表的位置和函数位置"></a>&lt;4&gt;定位到got表的位置和函数位置</h5><p>然后我们拿到字符串的偏移值进行定位到got表，再进一步定位到函数</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">/<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-number">2</span>.<span class="hljs-string">``</span>拿到字符串表<span class="hljs-string">``</span>  <span class="hljs-string">``</span>Elf64_Shdr shdr;<span class="hljs-string">``</span>  <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>定位字符串，节表地址加字符串表偏移×节表个数<span class="hljs-string">``</span>  <span class="hljs-string">``</span>lseek(fp,shof<span class="hljs-string">``</span>+<span class="hljs-string">``</span>shstr<span class="hljs-string">``</span>*<span class="hljs-string">``</span>shsize,SEEK_SET);<span class="hljs-string">``</span>  <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>此时节表就定位到字符串表开头<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-keyword">read</span>(fp,&amp;shdr,shsize);<span class="hljs-string">``</span>  <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>分配一个字符串表大小<span class="hljs-string">``</span>  <span class="hljs-string">``</span>char<span class="hljs-string">``</span>*<span class="hljs-string">` `</span>strtable <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>(char <span class="hljs-string">``</span>*<span class="hljs-string">``</span>)malloc(shdr.sh_size);<span class="hljs-string">``</span>  <span class="hljs-string">``</span>__android_log_print(<span class="hljs-string">``</span><span class="hljs-number">6</span><span class="hljs-string">``</span>,<span class="hljs-string">``</span><span class="hljs-string">&quot;windaa&quot;</span><span class="hljs-string">``</span>,<span class="hljs-string">``</span><span class="hljs-string">&quot;shdrsize %p&quot;</span><span class="hljs-string">``</span>,shdr.sh_offset);<span class="hljs-string">``</span>  <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>将字符串片指针移动到<span class="hljs-string">``</span><span class="hljs-number">0x34104</span><span class="hljs-string">``</span>上<span class="hljs-string">``</span>  <span class="hljs-string">``</span>lseek(fp,shdr.sh_offset,SEEK_SET);<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-keyword">read</span>(fp,strtable,shdr.sh_size);<span class="hljs-string">``</span>  <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>将指针移动到节表开头<span class="hljs-string">``</span>  <span class="hljs-string">``</span>lseek(fp,shof,SEEK_SET);<span class="hljs-string">` `</span>  <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>遍历查找到got<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-keyword">for</span><span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-keyword">int</span><span class="hljs-string">` `</span>i<span class="hljs-string">``</span>=<span class="hljs-string">``</span><span class="hljs-number">0</span><span class="hljs-string">``</span>;i&lt;shnum;i<span class="hljs-string">``</span>+<span class="hljs-string">``</span>+<span class="hljs-string">``</span>)&#123;<span class="hljs-string">``</span>    <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>从节表开头开始读取字符串，每次读取一个节表<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-keyword">read</span>(fp,&amp;shdr,shsize);<span class="hljs-string">``</span>    <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>通过节表的索引找到字符串表中对应的值<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-keyword">if</span><span class="hljs-string">``</span>(strcmp(&amp;strtable[shdr.sh_name], <span class="hljs-string">``</span><span class="hljs-string">&quot;.got&quot;</span><span class="hljs-string">``</span>)<span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">``</span><span class="hljs-number">0</span><span class="hljs-string">``</span>)&#123;<span class="hljs-string">``</span>      <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>定位到got表的地址<span class="hljs-string">``</span>      <span class="hljs-string">``</span><span class="hljs-keyword">int</span><span class="hljs-string">``</span>*<span class="hljs-string">` `</span>saddr <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>start<span class="hljs-string">``</span>+<span class="hljs-string">``</span>shdr.sh_addr<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-number">4</span><span class="hljs-string">``</span>;<span class="hljs-string">``</span>      <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>整个got表的大小<span class="hljs-string">``</span>      <span class="hljs-string">``</span><span class="hljs-keyword">int</span><span class="hljs-string">` `</span>size <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>shdr.sh_size;<span class="hljs-string">``</span>      <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>遍历got表中的函数<span class="hljs-string">``</span>      <span class="hljs-string">``</span><span class="hljs-keyword">for</span><span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-keyword">int</span><span class="hljs-string">` `</span>j<span class="hljs-string">``</span>=<span class="hljs-string">``</span><span class="hljs-number">0</span><span class="hljs-string">``</span>;j&lt;size;j<span class="hljs-string">``</span>=<span class="hljs-string">``</span>j<span class="hljs-string">``</span>+<span class="hljs-string">``</span><span class="hljs-number">8</span><span class="hljs-string">``</span>)&#123;<span class="hljs-string">``</span>        <span class="hljs-string">``</span>uint64_t value <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>*<span class="hljs-string">``</span>(uint64_t <span class="hljs-string">``</span>*<span class="hljs-string">``</span>)(saddr <span class="hljs-string">``</span>+<span class="hljs-string">` `</span>j <span class="hljs-string">``</span>/<span class="hljs-string">` `</span><span class="hljs-number">4</span><span class="hljs-string">``</span>);<span class="hljs-string">``</span>        <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>找到mywind的地址<span class="hljs-string">``</span>        <span class="hljs-string">``</span><span class="hljs-keyword">if</span><span class="hljs-string">``</span>(reinterpret_cast&lt;uint64_t&gt;(mywin<span class="hljs-number">0</span>) <span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">` `</span>value)<span class="hljs-string">``</span>        <span class="hljs-string">``</span>&#123;<span class="hljs-string">``</span>          <span class="hljs-string">``</span>__android_log_print(<span class="hljs-string">``</span><span class="hljs-number">6</span><span class="hljs-string">``</span>,<span class="hljs-string">``</span><span class="hljs-string">&quot;windaa&quot;</span><span class="hljs-string">``</span>,<span class="hljs-string">``</span><span class="hljs-string">&quot;value %p&quot;</span><span class="hljs-string">``</span>,value);<span class="hljs-string">``</span>          <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>替换mywind地址<span class="hljs-string">``</span>          <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">` `</span>获取当前内存分页的大小<span class="hljs-string">``</span>          <span class="hljs-string">``</span>uint64_t page_size <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>getpagesize();<span class="hljs-string">``</span>          <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">` `</span>获取内存分页的起始地址（需要内存对齐）<span class="hljs-string">``</span>          <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>page要保护的是函数的绝对地址，而不是相对地址<span class="hljs-string">``</span>          <span class="hljs-string">``</span>uint64_t entry_page_start <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>(uint64_t)(saddr<span class="hljs-string">``</span>+<span class="hljs-string">``</span>j<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-number">4</span><span class="hljs-string">``</span>) &amp; (~(page_size <span class="hljs-string">``</span>-<span class="hljs-string">` `</span><span class="hljs-number">1</span><span class="hljs-string">``</span>));<span class="hljs-string">``</span>          <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">` `</span>修改内存属性为可读可写可执行<span class="hljs-string">``</span>          <span class="hljs-string">``</span><span class="hljs-keyword">if</span><span class="hljs-string">``</span>(mprotect((uint64_t<span class="hljs-string">``</span>*<span class="hljs-string">``</span>)entry_page_start, page_size, PROT_READ | PROT_WRITE | PROT_EXEC) <span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">` `</span>-<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>)&#123;<span class="hljs-string">``</span>            <span class="hljs-string">``</span>__android_log_print(<span class="hljs-string">``</span><span class="hljs-number">6</span><span class="hljs-string">``</span>,<span class="hljs-string">``</span><span class="hljs-string">&quot;windaa&quot;</span><span class="hljs-string">``</span>,<span class="hljs-string">``</span><span class="hljs-string">&quot;%s&quot;</span><span class="hljs-string">``</span>,<span class="hljs-string">``</span><span class="hljs-string">&quot;mprotect failed&quot;</span><span class="hljs-string">``</span>);<span class="hljs-string">``</span>          <span class="hljs-string">``</span>&#125;<span class="hljs-string">``</span>          <span class="hljs-string">``</span>value <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>(uint64_t)mywin1;<span class="hljs-string">``</span>          <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>将mywind<span class="hljs-number">0</span>函数的地址换成mywind1函数的地址<span class="hljs-string">``</span>          <span class="hljs-string">``</span>memcpy((saddr<span class="hljs-string">``</span>+<span class="hljs-string">``</span>j<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-number">4</span><span class="hljs-string">``</span>),&amp;value,<span class="hljs-string">``</span><span class="hljs-number">16</span><span class="hljs-string">``</span>);<span class="hljs-string">``</span>        <span class="hljs-string">``</span>&#125;<span class="hljs-string">`  `</span>      <span class="hljs-string">``</span>&#125;<span class="hljs-string">``</span>    <span class="hljs-string">``</span>&#125;<span class="hljs-string">``</span>  <span class="hljs-string">``</span>&#125;<br></code></pre></td></tr></table></figure><p>显示详细信息</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_TX7ZCATWPAERB55.png" alt="image-20220517193556517"></p><p>这里我们就可以发现成功的hook</p><p>got hook使用姿势：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">（<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>）使用<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-built_in">proc</span><span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-variable language_">self</span><span class="hljs-string">``</span>/<span class="hljs-string">``</span>maps去获得so模块的加载地址<span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">2</span><span class="hljs-string">``</span>）使用<span class="hljs-title class_">ElfHeader</span>找到<span class="hljs-title class_">Section</span>的首地址，并计算offset和size来获取<span class="hljs-title class_">StringTable</span><span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">3</span><span class="hljs-string">``</span>）找到got表位置，计算其内存位置，并指针指向got表首地址<span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">4</span><span class="hljs-string">``</span>）遍历got表中的函数，找到要hook的函数，使用mprotect进行hook<span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">5</span><span class="hljs-string">``</span>）将hook的函数地址替换为我们定义的函数地址<br></code></pre></td></tr></table></figure><h3 id="5-Unicorn-hook使用"><a href="#5-Unicorn-hook使用" class="headerlink" title="5.Unicorn hook使用"></a>5.Unicorn hook使用</h3><p>这里我们简单了解一下基于unicorn的框架Unidbg的hook使用</p><p>开源地址：<a href="https://github.com/zhkl0228/unidbg">https://github.com/zhkl0228/unidbg</a></p><p>这里我们直接idea将项目拉取下来，然后等下项目环境配置完成</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_KR77QZB8XUD3JQQ.png" alt="image-20220517214320334"></p><p>配置完成后，我们直接启动里面的示例代码查看hook效果</p><p><img src="https://bbs.pediy.com/upload/attach/202205/905443_JJDDRDSMTYJCX7D.png" alt="image-20220517214506632"></p><p>这里unidbg使用了xHook，xHook是一种PLT hook的方式，当然这只是unidbg强大功能其中的一种，也是hook技术中一种，这里就简单介绍到这，后续再详细讲如何使用</p><p>unidbg使用参考博客：<a href="https://www.qinless.com/670">https://www.qinless.com/670</a></p><h2 id="六、实验总结"><a href="#六、实验总结" class="headerlink" title="六、实验总结"></a>六、实验总结</h2><p>本文从程序加载的原理出发，讲解了当下常用的一些基本的hook方式和手段，后续对其中一些hook方式再次深入讲解，实验的一些样本和代码会上传到知识星球和github，文章参考学了了很多大佬的文章和大佬星球的内容，参考文献放在末尾，有什么问题，就请各位大佬一一指出了。</p><p>github的地址：<a href="https://github.com/WindXaa">github</a></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>参考书籍：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">参考书目：《程序员的自我修养——链接、装载与库》<br></code></pre></td></tr></table></figure><p>GOT和PLT:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">https:<span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>www.geek<span class="hljs-string">``</span>-<span class="hljs-string">``</span>share.com<span class="hljs-string">``</span>/<span class="hljs-string">``</span>detail<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-number">2774116640.</span>html<span class="hljs-string">``</span>https:<span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>www.jianshu.com<span class="hljs-string">``</span>/<span class="hljs-string">``</span>p<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-number">0</span>ac63c3744dd<span class="hljs-string">``</span>https:<span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>www.zhihu.com<span class="hljs-string">``</span>/<span class="hljs-string">``</span>question<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-number">21249496</span><span class="hljs-string">``</span>https:<span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>www.codeleading.com<span class="hljs-string">``</span>/<span class="hljs-string">``</span>article<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-number">37234101170</span><span class="hljs-string">``</span>/<br></code></pre></td></tr></table></figure><p>hook技术</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">https:<span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>zhuanlan.zhihu.com<span class="hljs-string">``</span>/<span class="hljs-string">``</span>p<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-number">389889716</span><span class="hljs-string">``</span>https:<span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>mabin004.github.io<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-number">2018</span><span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-number">07</span><span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-number">31</span><span class="hljs-string">``</span>/<span class="hljs-string">``</span>Mac<span class="hljs-string">``</span>%<span class="hljs-string">``</span>E4<span class="hljs-string">``</span>%<span class="hljs-string">``</span>B8<span class="hljs-string">``</span>%<span class="hljs-string">``</span><span class="hljs-number">8</span>A<span class="hljs-string">``</span>%<span class="hljs-string">``</span>E7<span class="hljs-string">``</span>%<span class="hljs-string">``</span>BC<span class="hljs-string">``</span>%<span class="hljs-string">``</span><span class="hljs-number">96</span><span class="hljs-string">``</span>%<span class="hljs-string">``</span>E8<span class="hljs-string">``</span>%<span class="hljs-string">``</span>AF<span class="hljs-string">``</span>%<span class="hljs-string">``</span><span class="hljs-number">91</span>Frida<span class="hljs-string">``</span>/<span class="hljs-string">``</span>https:<span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>zhuanlan.zhihu.com<span class="hljs-string">``</span>/<span class="hljs-string">``</span>p<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-number">269441842</span><span class="hljs-string">``</span>https:<span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>blog.csdn.net<span class="hljs-string">``</span>/<span class="hljs-string">``</span>sdoyuxuan<span class="hljs-string">``</span>/<span class="hljs-string">``</span>article<span class="hljs-string">``</span>/<span class="hljs-string">``</span>details<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-number">78481239</span><span class="hljs-string">``</span>https:<span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>www.cnblogs.com<span class="hljs-string">``</span>/<span class="hljs-string">``</span>codingmengmeng<span class="hljs-string">``</span>/<span class="hljs-string">``</span>p<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-number">6046481.</span>html<span class="hljs-string">``</span>https:<span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>blog.csdn.net<span class="hljs-string">``</span>/<span class="hljs-string">``</span>sssssuuuuu666<span class="hljs-string">``</span>/<span class="hljs-string">``</span>article<span class="hljs-string">``</span>/<span class="hljs-string">``</span>details<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-number">78788369</span><span class="hljs-string">``</span>https:<span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>www.malwaretech.com<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-number">2015</span><span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-number">01</span><span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-keyword">inline</span><span class="hljs-string">``</span>-<span class="hljs-string">``</span>hooking<span class="hljs-string">``</span>-<span class="hljs-string">``</span>for<span class="hljs-string">``</span>-<span class="hljs-string">``</span>programmers<span class="hljs-string">``</span>-<span class="hljs-string">``</span>part<span class="hljs-string">``</span>-<span class="hljs-string">``</span><span class="hljs-number">1.</span>html<span class="hljs-string">``</span>https:<span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>juejin.<span class="hljs-literal">cn</span><span class="hljs-string">``</span>/<span class="hljs-string">``</span>post<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-number">6844903993668272141</span><br></code></pre></td></tr></table></figure><p>got&#x2F;plt hook:</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nsis">https:<span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>www.likecs.com<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-literal">show</span><span class="hljs-string">``</span>-<span class="hljs-string">``</span><span class="hljs-number">203321775</span>.html<span class="hljs-string">``</span>https:<span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>www.lmlphp.com<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-literal">user</span><span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-number">65342</span><span class="hljs-string">``</span>/<span class="hljs-string">``</span>article<span class="hljs-string">``</span>/<span class="hljs-string">``</span>item<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-number">709806</span><span class="hljs-string">``</span>/<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>移动安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>移动安全</tag>
      
      <tag>HOOK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用frida hook对app的常用关键代码进行定位</title>
    <link href="/2023/08/31/%E4%BD%BF%E7%94%A8frida%20hook%E5%AF%B9app%E7%9A%84%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8C%E5%AE%9A%E4%BD%8D/"/>
    <url>/2023/08/31/%E4%BD%BF%E7%94%A8frida%20hook%E5%AF%B9app%E7%9A%84%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8C%E5%AE%9A%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="使用frida-hook对app的常用关键代码进行定位"><a href="#使用frida-hook对app的常用关键代码进行定位" class="headerlink" title="使用frida hook对app的常用关键代码进行定位"></a>使用frida hook对app的常用关键代码进行定位</h1><p>有时候可能会对APP进行字符串加密等操作，这样的话你的变量名等一些都被混淆了，看代码就可能无从下手</p><p>不管没关系，像系统级别的东西，<code>Toast</code>了等函数，是不能混淆的，所以可以根据蛛丝马迹，终究找到破解的点</p><h2 id="frida常用命令"><a href="#frida常用命令" class="headerlink" title="frida常用命令"></a>frida常用命令</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stata">frida<br> -<span class="hljs-keyword">U</span> 连接USB设备<br>    -F 附加到最前面的<span class="hljs-keyword">app</span><br>    -<span class="hljs-keyword">l</span> 注入的js<br> -o 输出到文件<br> -f 重新启动<br> --<span class="hljs-keyword">no</span>-<span class="hljs-keyword">pause</span> 立马执行,中间不停顿<br></code></pre></td></tr></table></figure><h2 id="打印堆栈"><a href="#打印堆栈" class="headerlink" title="打印堆栈"></a>打印堆栈</h2><p>打印堆栈的本质就是抛异常，他的结果是从下往上看的！</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">printStacks</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<br>        Java.use(<span class="hljs-string">&quot;android.util.Log&quot;</span>)<br>        .getStackTraceString(<br>            Java.use(<span class="hljs-string">&quot;java.lang.Throwable&quot;</span>).$<span class="hljs-keyword">new</span>()<br>        )<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><h2 id="常用hook函数代码"><a href="#常用hook函数代码" class="headerlink" title="常用hook函数代码"></a>常用hook函数代码</h2><h3 id="hook-HashMap的put方法"><a href="#hook-HashMap的put方法" class="headerlink" title="hook HashMap的put方法"></a>hook HashMap的put方法</h3><p>hashMap,，那就很常用了，懂的都懂，但是一定要做好筛选，要不然app容易崩溃！</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> hashMap = Java.use(<span class="hljs-string">&quot;java.util.HashMap&quot;</span>);<br>hashMap.put.implementation = <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-comment">//a==&quot;username&quot;和a.equals(&quot;username&quot;)一般都可以</span><br>    <span class="hljs-comment">//如果不行换一下即可</span><br>    <span class="hljs-keyword">if</span> (a==<span class="hljs-string">&quot;username&quot;</span>) &#123;<br>     <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;hashMap.put: &quot;</span>, a, b);<br>        printStacks();<br> &#125;<br> <span class="hljs-keyword">return</span> this.put(a, b);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="hook-ArrayList的add方法"><a href="#hook-ArrayList的add方法" class="headerlink" title="hook ArrayList的add方法"></a>hook ArrayList的add方法</h3><p>Array似乎也很常用</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> arrayList = Java.use(<span class="hljs-string">&quot;java.util.ArrayList&quot;</span>);<br>arrayList.add.overload(<span class="hljs-string">&#x27;java.lang.Object&#x27;</span>).implementation = <span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) &#123;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-string">&quot;username=18903916120&quot;</span>) &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;arrayList.add: &quot;</span>, a);<br>        printStacks();  <br>    &#125;<br>    <span class="hljs-comment">//console.log(&quot;arrayList.add: &quot;, a);</span><br>    <span class="hljs-keyword">return</span> this.add(a);<br>&#125;<br>arrayList.add.overload(<span class="hljs-string">&#x27;int&#x27;</span>, <span class="hljs-string">&#x27;java.lang.Object&#x27;</span>).implementation = <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;arrayList.add: &quot;</span>, a, b);<br>    <span class="hljs-keyword">return</span> this.add(a, b);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="hook-TextUtils的isEmpty方法"><a href="#hook-TextUtils的isEmpty方法" class="headerlink" title="hook TextUtils的isEmpty方法"></a>hook TextUtils的isEmpty方法</h3><p>这个方法通常是安卓判断输入框是否为空必经的方法！</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> textUtils = Java.use(<span class="hljs-string">&quot;android.text.TextUtils&quot;</span>);<br>textUtils.<span class="hljs-built_in">isEmpty</span>.implementation = <span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) &#123;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-string">&quot;TURJNk1EQTZNREE2TURBNk1EQTZNREE9&quot;</span>) &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;textUtils.isEmpty: &quot;</span>, a);<br>        printStacks();<br><br>    &#125;<br>    <span class="hljs-comment">//console.log(&quot;textUtils.isEmpty: &quot;, a);</span><br>    <span class="hljs-keyword">return</span> this.<span class="hljs-built_in">isEmpty</span>(a);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="hook-String的trim方法"><a href="#hook-String的trim方法" class="headerlink" title="hook String的trim方法"></a>hook String的trim方法</h3><p>这个方法似乎也挺多，去掉开头和结尾的空格，防止脏数据</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> str = Java.use(<span class="hljs-string">&quot;java.lang.String&quot;</span>);<br>str.<span class="hljs-built_in">trim</span>.implementation = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;str.trim: &quot;</span>,  this);<br>    printStacks();<br>    <span class="hljs-keyword">return</span> this.<span class="hljs-built_in">trim</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="hook-log的w方法"><a href="#hook-log的w方法" class="headerlink" title="hook log的w方法"></a>hook log的w方法</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> <span class="hljs-built_in">log</span> = Java.use(<span class="hljs-string">&quot;android.util.Log&quot;</span>);<br>    <span class="hljs-built_in">log</span>.w.overload(<span class="hljs-string">&#x27;java.lang.String&#x27;</span>, <span class="hljs-string">&#x27;java.lang.String&#x27;</span>).implementation = <span class="hljs-keyword">function</span> (<span class="hljs-params">tag, message</span>) &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;log.w: &quot;</span>, tag, message);<br>        printStacks();<br>        <span class="hljs-keyword">return</span> this.w(tag, message);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="hook-EditText的getText方法"><a href="#hook-EditText的getText方法" class="headerlink" title="hook EditText的getText方法"></a>hook EditText的getText方法</h3><p>这个应该就多了，但是这个一般在加密的上层，可以考虑使用。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">var</span> editText = <span class="hljs-type">Java</span>.use(<span class="hljs-string">&quot;android.widget.EditText&quot;</span>);<br>editText.getText.overload().implementation = function () &#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-built_in">result</span> = this.getText();<br>    <span class="hljs-built_in">result</span> = <span class="hljs-type">Java</span>.<span class="hljs-keyword">cast</span>(<span class="hljs-built_in">result</span>, <span class="hljs-type">Java</span>.use(<span class="hljs-string">&quot;java.lang.CharSequence&quot;</span>));<br>    console.log(<span class="hljs-string">&quot;editText.getText: &quot;</span>, <span class="hljs-built_in">result</span>.toString());<br>    printStacks();<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">result</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="hook-Collections的sort方法"><a href="#hook-Collections的sort方法" class="headerlink" title="hook Collections的sort方法"></a>hook Collections的sort方法</h3><p>排序方法，频率还凑合</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> collections = Java.use(<span class="hljs-string">&quot;java.util.Collections&quot;</span>);<br>collections.<span class="hljs-built_in">sort</span>.overload(<span class="hljs-string">&#x27;java.util.List&#x27;</span>).implementation = <span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) &#123;<br>    <span class="hljs-keyword">var</span> result = Java.cast(a, Java.use(<span class="hljs-string">&quot;java.util.ArrayList&quot;</span>));<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;collections.sort List: &quot;</span>, result.toString());<br>    printStacks();<br>    <span class="hljs-keyword">return</span> this.<span class="hljs-built_in">sort</span>(a);<br>&#125;<br>collections.<span class="hljs-built_in">sort</span>.overload(<span class="hljs-string">&#x27;java.util.List&#x27;</span>, <span class="hljs-string">&#x27;java.util.Comparator&#x27;</span>).implementation = <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-keyword">var</span> result = Java.cast(a, Java.use(<span class="hljs-string">&quot;java.util.ArrayList&quot;</span>));<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;collections.sort List Comparator: &quot;</span>, result.toString());<br>    printStacks();<br>    <span class="hljs-keyword">return</span> this.<span class="hljs-built_in">sort</span>(a, b);<br>&#125;<br><span class="hljs-comment">// .overload(&#x27;java.lang.String&#x27;, &#x27;double&#x27;)</span><br><span class="hljs-comment">// .overload(&#x27;java.lang.String&#x27;, &#x27;int&#x27;)</span><br><span class="hljs-comment">// .overload(&#x27;java.lang.String&#x27;, &#x27;long&#x27;)</span><br><span class="hljs-comment">// .overload(&#x27;java.lang.String&#x27;, &#x27;boolean&#x27;)</span><br></code></pre></td></tr></table></figure><h3 id="hook-jSONObject的put方法"><a href="#hook-jSONObject的put方法" class="headerlink" title="hook jSONObject的put方法"></a>hook jSONObject的put方法</h3><p>一般在转成json时用的听过的，可以考虑</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> jSONObject = Java.use(<span class="hljs-string">&quot;org.json.JSONObject&quot;</span>);<br>jSONObject.put.overload(<span class="hljs-string">&#x27;java.lang.String&#x27;</span>, <span class="hljs-string">&#x27;java.lang.Object&#x27;</span>).implementation = <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-comment">//var result = Java.cast(a, Java.use(&quot;java.util.ArrayList&quot;));</span><br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;jSONObject.put: &quot;</span>, a, b);<br>    printStacks();<br>    <span class="hljs-keyword">return</span> this.put(a, b);<br>&#125;<br>jSONObject.getString.implementation = <span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) &#123;<br>    <span class="hljs-comment">//var result = Java.cast(a, Java.use(&quot;java.util.ArrayList&quot;));</span><br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;jSONObject.getString: &quot;</span>, a);<br>    <span class="hljs-keyword">var</span> result = this.getString(a);<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;jSONObject.getString result: &quot;</span>, result);<br>    printStacks();<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="hook-Toast的show方法"><a href="#hook-Toast的show方法" class="headerlink" title="hook Toast的show方法"></a>hook Toast的show方法</h3><p>这个就很多了，基本上每个app都有，但是hook这个位置又偏加密下层，因为肯定是处理完才弹窗</p><p>但是可以考虑不输入账号密码直接提交，这样位置大概在加密的上层，可以顺着往下走</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var toast <span class="hljs-operator">=</span> Java.use(<span class="hljs-string">&quot;android.widget.Toast&quot;</span>)<span class="hljs-comment">;</span><br>toast.show.implementation <span class="hljs-operator">=</span> function () &#123;<br>    console.log(<span class="hljs-string">&quot;toast.show: &quot;</span>)<span class="hljs-comment">;</span><br>    printStacks()<span class="hljs-comment">;</span><br>    return this.show()<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="hook-Base64的encodeToString方法"><a href="#hook-Base64的encodeToString方法" class="headerlink" title="hook Base64的encodeToString方法"></a>hook Base64的encodeToString方法</h3><p>base64就很多了吧，除了消息摘要算法其他最后的形式都是base64格式，很有必要。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> base64 = Java.use(<span class="hljs-string">&quot;android.util.Base64&quot;</span>);<br>base64.encodeToString.overload(<span class="hljs-string">&#x27;[B&#x27;</span>, <span class="hljs-string">&#x27;int&#x27;</span>).implementation = <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;base64.encodeToString: &quot;</span>, JSON.stringify(a));<br>    <span class="hljs-keyword">var</span> result = this.encodeToString(a, b);<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;base64.encodeToString result: &quot;</span>, result)<br>    printStacks();<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="hook-String的getBytes方法"><a href="#hook-String的getBytes方法" class="headerlink" title="hook String的getBytes方法"></a>hook String的getBytes方法</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> str = Java.use(<span class="hljs-string">&quot;java.lang.String&quot;</span>);<br>str.getBytes.overload().implementation = <span class="hljs-function"><span class="hljs-keyword">function</span> </span>() &#123;<br>    <span class="hljs-keyword">var</span> result = <span class="hljs-built_in">this</span>.getBytes();<br>    <span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Str</span> = str.$<span class="hljs-keyword">new</span><span class="hljs-type"></span>(result);<br>    console.log(<span class="hljs-string">&quot;str.getBytes result: &quot;</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Str</span>);<br>    printStacks();<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br>str.getBytes.overload(<span class="hljs-string">&#x27;java.lang.String&#x27;</span>).implementation = <span class="hljs-function"><span class="hljs-keyword">function</span> </span>(a) &#123;<br>    <span class="hljs-keyword">var</span> result = <span class="hljs-built_in">this</span>.getBytes(a);<br>    <span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Str</span> = str.$<span class="hljs-keyword">new</span><span class="hljs-type"></span>(result, a);<br>    console.log(<span class="hljs-string">&quot;str.getBytes result: &quot;</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Str</span>);<br>    printStacks();<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="findViewById找控件方法"><a href="#findViewById找控件方法" class="headerlink" title="findViewById找控件方法"></a>findViewById找控件方法</h3><p>这种方式hook代码，需要frida帮助我们启动app。</p><p>所以本次启动的命令为</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">frida -U -f com<span class="hljs-selector-class">.dodonew</span><span class="hljs-selector-class">.online</span> -l g_关键代码快速定位<span class="hljs-selector-class">.js</span> -o <span class="hljs-number">1</span><span class="hljs-selector-class">.txt</span> <span class="hljs-attr">--no-pause</span><br></code></pre></td></tr></table></figure><p>因为可能一开始就绑定了很多控件，所以一开始就要开始hook。</p><h4 id="如何找控件id"><a href="#如何找控件id" class="headerlink" title="如何找控件id"></a>如何找控件id</h4><p>控件id可以通过<code>&lt;SDK目录&gt;\tools\bin</code>下的<code>uiautomatorviewer.bat</code>来进行查看</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><h4 id="查看登录按钮id"><a href="#查看登录按钮id" class="headerlink" title="查看登录按钮id"></a>查看登录按钮id</h4><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><p>所以这个登录按钮的id就是<code>btn_login</code></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 找id</span><br><span class="hljs-keyword">var</span> btn_login_id = Java.use(<span class="hljs-string">&quot;com.dodonew.online.R$id&quot;</span>).btn_login.value;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;btn_login_id:&quot;</span>, btn_login_id);<br><br><span class="hljs-keyword">var</span> view = Java.use(<span class="hljs-string">&quot;android.view.View&quot;</span>);<br>view.setOnClickListener.implementation = <span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) &#123;<br>     <span class="hljs-keyword">if</span>(this.getId() == btn_login_id)&#123;<br>         <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;view.id: &quot;</span> + this.getId());<br>         <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;view.setOnClickListener is called&quot;</span>);<br>         printStacks();<br>     &#125;<br>    <span class="hljs-keyword">return</span> this.setOnClickListener(a);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="简单用法"><a href="#简单用法" class="headerlink" title="简单用法"></a>简单用法</h2><p>在嘟嘟牛这个app中，最后使用的是DES算法，并且base64结果展示加密的内容。</p><p>所以就hook一下base64试试</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Java.<span class="hljs-keyword">perform</span>(<span class="hljs-keyword">function</span> () &#123;<br>    //打印堆栈<br>    <span class="hljs-keyword">function</span> printStacks() &#123;<br>        console.log(<br>            Java.use(&quot;android.util.Log&quot;)<br>                .getStackTraceString(<br>                    Java.use(&quot;java.lang.Throwable&quot;).$<span class="hljs-built_in">new</span>()<br>                )<br>        );<br>    &#125;<br>    //base64<br>    var base64 = Java.use(&quot;android.util.Base64&quot;);<br>    base64.encodeToString.overload(<span class="hljs-string">&#x27;[B&#x27;</span>, <span class="hljs-string">&#x27;int&#x27;</span>).implementation = <span class="hljs-keyword">function</span> (a, b) &#123;<br>        console.log(&quot;base64.encodeToString: &quot;, <span class="hljs-type">JSON</span>.stringify(a));<br>        var result = this.encodeToString(a, b);<br>        console.log(&quot;base64.encodeToString result: &quot;, result)<br>        printStacks();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="hook结果"><a href="#hook结果" class="headerlink" title="hook结果"></a>hook结果</h3><p>所以如果说，你如果看结果像是base或者md5或者hex等，直接就使用这些常用的hook代码试一下，并且抛出堆栈。</p><p>就可以很好分析代码了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然写的是关键代码定位，其实只不过是常用的代码罢了，上面这些使用在逆向app时总结的hook代码。</p>]]></content>
    
    
    <categories>
      
      <category>移动安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>移动安全</tag>
      
      <tag>HOOK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>整体加壳原理和脱壳技巧详解</title>
    <link href="/2023/08/31/%E6%95%B4%E4%BD%93%E5%8A%A0%E5%A3%B3%E5%8E%9F%E7%90%86%E5%92%8C%E8%84%B1%E5%A3%B3%E6%8A%80%E5%B7%A7%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/08/31/%E6%95%B4%E4%BD%93%E5%8A%A0%E5%A3%B3%E5%8E%9F%E7%90%86%E5%92%8C%E8%84%B1%E5%A3%B3%E6%8A%80%E5%B7%A7%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="整体加壳原理和脱壳技巧详解"><a href="#整体加壳原理和脱壳技巧详解" class="headerlink" title="整体加壳原理和脱壳技巧详解"></a>整体加壳原理和脱壳技巧详解</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>为了帮助更加方便的进行漏洞挖掘工作，前面我们通过了几篇文章详解的给大家介绍了动态调试技术、过反调试技术、Hook技术、过反Hook技术、抓包技术等，掌握了这些可以很方便的开展App漏洞挖掘工作，而最后我们还需要掌握一定的脱壳技巧，进行进一步助力我们漏洞挖掘的效率，本文主要介绍Android App加壳中的整体dex加壳，帮助大家掌握加壳的原理和脱壳的各种技能。</p><p>本文第二节主要讲述Android启动流程和加壳原理</p><p>本文第三节主要介绍整体加壳的实现</p><p>本文第四节主要讲当下脱壳点的概念</p><p>本文第五节讲述现有的脱壳技巧</p><h2 id="二、相关介绍"><a href="#二、相关介绍" class="headerlink" title="二、相关介绍"></a>二、相关介绍</h2><h3 id="1-Android-App启动流程"><a href="#1-Android-App启动流程" class="headerlink" title="1.Android App启动流程"></a>1.Android App启动流程</h3><h4 id="（1）Android系统启动流程"><a href="#（1）Android系统启动流程" class="headerlink" title="（1）Android系统启动流程"></a>（1）Android系统启动流程</h4><p>我们要彻底的了解App加壳原理，首先我们从了解App的启动流程出发，先于App启动之前，Android系统是启动最早，下面我们来详细查看一下Android系统的启动过程：</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_HWHGFFQYNTE4R7R.png" alt="img"></p><p>我在<a href="https://blog.csdn.net/hzwailll/article/details/85339714">Xposed源码定制</a>一文中详细的讲解了Android的启动流程，简单来说就是：</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_UHMM7HFWYUPGHG5.png" alt="img"></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">加载BootLoader <span class="hljs-string">``</span>-<span class="hljs-string">``</span>-<span class="hljs-string">``</span>&gt; 初始化内核 <span class="hljs-string">``</span>-<span class="hljs-string">``</span>-<span class="hljs-string">``</span>&gt; 启动init进程 <span class="hljs-string">``</span>-<span class="hljs-string">``</span>-<span class="hljs-string">``</span>&gt; init进程<span class="hljs-keyword">fork</span>出Zygote进程 <span class="hljs-string">``</span>-<span class="hljs-string">``</span>-<span class="hljs-string">``</span>&gt; Zygote进程<span class="hljs-keyword">fork</span>出SystemServer进程<br></code></pre></td></tr></table></figure><p>我们就了解了最后Zygote进程fork出第一个进程：<code>SystemServer</code>进程，SystemServer主要完成了以下工作：</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_SCMEW4UR29WHZ5H.png" alt="image-20220612154820955"></p><p><strong>android app安装</strong></p><p>首先这里我们先介绍一下<code>PackageManagerService</code>，其主要是完成Android中应用程序安装的服务，我们了解的Android应用程序安装的方式：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">· 系统启动时安装，没有安装界面<span class="hljs-string">``</span>· 第三方应用安装，有安装界面，也是我们最熟悉的方式<span class="hljs-string">``</span>· ADB命令安装，没有安装界面<span class="hljs-string">``</span>· 通过各类应用市场安装，没有安装界面<br></code></pre></td></tr></table></figure><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_U3H8TXWP4AD2PPJ.png" alt="image-20220612154820955"></p><p>虽然安装方式不同，但是最后四种方式都是通过PackageManagerService服务来完成应用程序的安装。而PackageManagerService服务则通过与Installd服务通信，发送具体的指令来执行应用程序的安装、卸载等工作</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> final <span class="hljs-title class_">IPackageManager</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">Context context, Installer installer,<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-built_in">boolean</span> factoryTest, <span class="hljs-built_in">boolean</span> onlyCore</span>) &#123;<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-title class_">PackageManagerService</span> m <span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">PackageManagerService</span>(context, installer, factoryTest, onlyCore);<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-title class_">ServiceManager</span>.<span class="hljs-title function_">addService</span>(<span class="hljs-string">``</span><span class="hljs-string">&quot;package&quot;</span><span class="hljs-string">``</span>, m);<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-keyword">return</span><span class="hljs-string">` `</span>m;<span class="hljs-string">``</span>&#125;<br></code></pre></td></tr></table></figure><p>应用程序在安装时涉及到如下几个重要目录：</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_RAGKRAPMYES3ECF.png" alt="image-20220612154820955"></p><p>我们了解完App的安装流程是由<code>PackageManagerService</code>，同理SystemServer启动了一个更加重要的服务<code>ActivityManagerService</code>, 而AMS其中很重要的一个作用就是启动<code>Launcher</code>进程，具体是怎么启动的，大家可以参考文章:<a href="https://blog.csdn.net/itachi85/article/details/56669808">Android系统启动流程（四）Launcher启动过程与系统启动流程</a>，这里就不再详细讲解，而进入<code>Launcher</code>进程，我们就进入了App启动的流程。</p><h4 id="（2）App启动流程"><a href="#（2）App启动流程" class="headerlink" title="（2）App启动流程"></a>（2）App启动流程</h4><p>Android系统启动的最后一步是启动一个Home应用程序，这个应用程序用来显示系统中已经安装的应用程序，这个Home应用程序就叫做Launcher。应用程序Launcher在启动过程中会请求PackageManagerService返回系统中已经安装的应用程序的信息，并将这些信息封装成一个快捷图标列表显示在系统屏幕上，这样用户可以通过点击这些快捷图标来启动相应的应用程序</p><p>前面我们描述了AMS将Launcher启动，然后进入App启动流程，这里参考文章：<a href="https://blog.csdn.net/hzwailll/article/details/85339714">ActivityThread的理解和APP的启动过程</a></p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_SV29GYJHB39FCYQ.png" alt="image-20220612154820955"></p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nsis">(<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>)点击桌面APP图标时，Launcher的startActivity()方法，通过Binder通信，调用<span class="hljs-params">system</span>_server进程中AMS服务的startActivity方法，发起启动请求<span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-number">2</span><span class="hljs-string">``</span>)<span class="hljs-params">system</span>_server进程接收到请求后，向Zygote进程发送创建进程的请求<span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-number">3</span><span class="hljs-string">``</span>)Zygote进程fork出App进程，并执行ActivityThread的main方法，创建ActivityThread线程，初始化MainLooper，主线程Handler，同时初始化ApplicationThread用于和AMS通信交互<span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-number">4</span><span class="hljs-string">``</span>)App进程，通过Binder向sytem_server进程发起attachApplication请求，这里实际上就是APP进程通过Binder调用sytem_server进程中AMS的attachApplication方法,AMS的attachApplication方法的作用是将ApplicationThread对象与AMS绑定<span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-number">5</span><span class="hljs-string">``</span>)<span class="hljs-params">system</span>_server进程在收到attachApplication的请求，进行一些准备工作后，再通过binder IPC向App进程发送handleBindApplication请求（初始化Application并调用onCreate方法）和scheduleLaunchActivity请求（创建启动Activity）<span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-number">6</span><span class="hljs-string">``</span>)App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送BIND_APPLICATION和LAUNCH_ACTIVITY消息，这里注意的是AMS和主线程并不直接通信，而是AMS和主线程的内部类ApplicationThread通过Binder通信，ApplicationThread再和主线程通过Handler消息交互。<span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-number">7</span><span class="hljs-string">``</span>)主线程在收到Message后，创建Application并调用onCreate方法，再通过反射机制创建目标Activity，并回调Activity.onCreate()等方法<span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-number">8</span><span class="hljs-string">``</span>)到此，App便正式启动，开始进入Activity生命周期，执行完onCreate<span class="hljs-string">``</span>/<span class="hljs-string">``</span>onStart<span class="hljs-string">``</span>/<span class="hljs-string">``</span>onResume方法，UI渲染后显示APP主界面<br></code></pre></td></tr></table></figure><p>显示详细信息</p><p>到这里，我们的大致弄清了APP的启动流程，而这里我们就进入了加壳中十分重要的地方<code>ActivityTread</code></p><h4 id="（3）ActivityThread启动流程"><a href="#（3）ActivityThread启动流程" class="headerlink" title="（3）ActivityThread启动流程"></a>（3）ActivityThread启动流程</h4><p>寒冰大佬在<a href="https://bbs.pediy.com/thread-252630.htm">FART：ART环境下基于主动调用的自动化脱壳方案 </a>一文中讲述了ActivityThread.main()是进入App世界的大门，并由此展开了对加壳原理的讲述</p><p>同理接下来，我们开始进行源码分析，了解ActivityThread的具体操作：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">xref<span class="hljs-regexp">/frameworks/</span>base<span class="hljs-regexp">/core/</span>java<span class="hljs-regexp">/android/</span>app/ActivityThread.java<br></code></pre></td></tr></table></figure><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_HX9Q8BSEZ8JJMHC.png" alt="image-20220612164337749"></p><p>根据寒冰大佬描述，在ActivityThread完成实例化操作，调用thread.attach(false)完成一系列初始化准备工作，最后主线程进入消息循环，等待接收来自系统的消息。当收到系统发送来的bindapplication的进程间调用时，调用函数<code>handlebindapplication</code>来处理该请求</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">handleMessage</span>(<span class="hljs-params">Message msg</span>) &#123;<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-keyword">case</span> <span class="hljs-attr">BIND_APPLICATION</span>:<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-title class_">Trace</span>.<span class="hljs-title function_">traceBegin</span>(<span class="hljs-title class_">Trace</span>.<span class="hljs-property">TRACE_TAG_ACTIVITY_MANAGER</span>, <span class="hljs-string">``</span><span class="hljs-string">&quot;bindApplication&quot;</span><span class="hljs-string">``</span>);<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-title class_">AppBindData</span> data <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>(<span class="hljs-title class_">AppBindData</span>)msg.<span class="hljs-property">obj</span>;<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-title function_">handleBindApplication</span>(data);<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-title class_">Trace</span>.<span class="hljs-title function_">traceEnd</span>(<span class="hljs-title class_">Trace</span>.<span class="hljs-property">TRACE_TAG_ACTIVITY_MANAGER</span>);<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-keyword">break</span><span class="hljs-string">``</span>;<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>&#125;<br></code></pre></td></tr></table></figure><p>在处理消息过程，很很明显进入了<code>handlebindapplication</code>函数</p><p>这里我再用寒冰大佬文章的内容：</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_JU6EE7TW5FT4XNU.png" alt="image-20220612164337749"></p><p>我们定位第四步，Application进行实例化，然后进入<code>makeApplication</code></p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_RVC45CG4KPD9XVH.png" alt="image-20220612165753498"></p><p>然后我们进入<code>newApplication</code></p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_HJZ2467PCSSBCWC.png" alt="image-20220612170020202"></p><p>这里我们可以看见完成了两件事：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">（<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>）完成了Application的实例化<span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">2</span><span class="hljs-string">``</span>）并调用Application.attach()函数<br></code></pre></td></tr></table></figure><p>然后我们继续进入<code>Application.attach()</code>函数</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_27PM6NT4U7Y7DK8.png" alt="image-20220612170305879"></p><p>这里我们就进一步调用了<code>attachBaseContext()</code>方法</p><p>最后回到<code>handlebindapplication</code>中执行第6步，进入callApplicationOnCreate()函数</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_M5RQV5H7S5KZ7U8.png" alt="image-20220612170604374"></p><p>就执行了<code>Application.onCreate()方法</code></p><p>总结：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">从上可知, App的运行流程是<span class="hljs-string">``</span>  <span class="hljs-string">``</span>初始化————&gt;Application的构造函数————&gt;Application.attachBaseContext()————&gt;Application.onCreate()函数<span class="hljs-string">``</span>最后才会进入MainActivity中的attachBaseContext函数、onCreate函数<span class="hljs-string">``</span>所以加壳厂商要在程序正式执行前，也就是上面的流程中进行动态加载和类加载器的修正，这样才能对加密的dex进行释放，而一般的<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>厂商往往选择在Application中的attachBaseContext或onCreate函数进行<br></code></pre></td></tr></table></figure><p>这里我附上网上一个大佬的详细执行流程图：</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_7PTGQ4KHBKHKEE7.png" alt="image-20220612170604374"></p><h3 id="2-整体加壳原理详解"><a href="#2-整体加壳原理详解" class="headerlink" title="2.整体加壳原理详解"></a>2.整体加壳原理详解</h3><h4 id="（1）整体加壳原理"><a href="#（1）整体加壳原理" class="headerlink" title="（1）整体加壳原理"></a>（1）整体加壳原理</h4><p>Dex整体加壳可以理解为在加密的源Apk程序外面有套上了一层外壳，简单过程为：</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_CUKE55Y24F43P3K.png" alt="image-20220424141415510"></p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_WU78GNFZH329X95.png" alt="image-20220424141415510"></p><p>如何对App进行加一层外壳呢，这里就需要应用动态加载的原理，关于动态加载和类加载器，我在上篇文章中有详细讲解：<a href="https://bbs.pediy.com/thread-271538.htm">Android加壳脱壳学习（1）——动态加载和类加载机制详解</a></p><p>这里我们可以用一个案例来进一步讲述，我们打开一个整体加壳的样本</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_GJ3YEYXBQ8K2A3M.png" alt="image-20220612172943793"></p><p>我们很明显看见，除了一个代理类Application，其他相关的代码信息都无法发现</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_9RTZWXTHR8AEJJX.png" alt="image-20220612173124912"></p><p>在代理类中反射调用了一些方法，很显然我们解析出的结果都无法查找，很明显就说明在Application.attchBaseContext()和Application.onCreate()中必须要完成对源加密的dex的动态加载和解密</p><p>结合上面的描述，App加载应用解析时就是这个流程：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">（<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>）BootClassLoader加载系统核心库<span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">2</span><span class="hljs-string">``</span>）PathClassLoader加载APP自身dex<span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">3</span><span class="hljs-string">``</span>）进入APP自身组件，解析AndroidManifest.<span class="hljs-built_in">xml</span>，然后查找Application代理<span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">4</span><span class="hljs-string">``</span>）调用声明Application的attachBaseContext()对源程序进行动态加载或解密<span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">5</span><span class="hljs-string">``</span>）调用声明Application的onCreate()对源程序进行动态加载或解密<span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">6</span><span class="hljs-string">``</span>）进入MainActivity中的attachBaseContext()，然后进入onCreate()函数，执行源程序代码<br></code></pre></td></tr></table></figure><h4 id="（2）类加载器的修正"><a href="#（2）类加载器的修正" class="headerlink" title="（2）类加载器的修正"></a>（2）类加载器的修正</h4><p>上面我们已经很清晰的了解了壳加载的流程，我们很明显的意识到一个问题，我们从头到尾都是用<code>PathClassLoader</code>来加载dex，而上篇文章我在讲类加载器的过程中说过</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_UYXZMYY8RKFYXSZ.png" alt="image-20220612185103615"></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-title class_">Android</span>中的<span class="hljs-title class_">ClassLoader</span>类型分为系统<span class="hljs-title class_">ClassLoader</span>和自定义<span class="hljs-title class_">ClassLoader</span>。其中系统<span class="hljs-title class_">ClassLoader</span>包括<span class="hljs-string">``</span><span class="hljs-number">3</span><span class="hljs-string">``</span>种是<span class="hljs-title class_">BootClassLoader</span>、<span class="hljs-title class_">DexClassLoader</span>、<span class="hljs-title class_">PathClassLoader</span><span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>)<span class="hljs-title class_">BootClassLoader</span><span class="hljs-symbol">:Android</span>平台上所有<span class="hljs-title class_">Android</span>系统启动时会使用<span class="hljs-title class_">BootClassLoader</span>来预加载常用的类<span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-number">2</span><span class="hljs-string">``</span>)<span class="hljs-title class_">BaseDexClassLoader</span><span class="hljs-symbol">:</span>实际应用层类文件的加载，而真正的加载委托给pathList来完成<span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-number">3</span><span class="hljs-string">``</span>)<span class="hljs-title class_">DexClassLoader</span><span class="hljs-symbol">:</span>可以加载dex文件以及包含dex的压缩文件(apk,dex,jar,<span class="hljs-string">``</span>zip<span class="hljs-string">``</span>),可以安装一个未安装的apk文件，一般为自定义类加载器<span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-number">4</span><span class="hljs-string">``</span>)<span class="hljs-title class_">PathClassLoader</span><span class="hljs-symbol">:</span>可以加载系统类和应用程序的类，通常用来加载已安装的apk的dex文件<span class="hljs-string">` `</span>补充：<span class="hljs-string">``</span><span class="hljs-title class_">Android</span> 提供的原生加载器叫做基础类加载器，包括：<span class="hljs-title class_">BootClassLoader</span>，<span class="hljs-title class_">PathClassLoader</span>，<span class="hljs-title class_">DexClassLoader</span>，<span class="hljs-title class_">InMemoryDexClassLoader</span>（<span class="hljs-title class_">Android</span> <span class="hljs-string">``</span><span class="hljs-number">8.0</span><span class="hljs-string">` `</span>引入），<span class="hljs-title class_">DelegateLastClassLoader</span>（<span class="hljs-title class_">Android</span> <span class="hljs-string">``</span><span class="hljs-number">8.1</span><span class="hljs-string">` `</span>引入）<br></code></pre></td></tr></table></figure><p>我们要想动态加载dex文件必须使用自定义的<code>DexClassLoader</code>，那我们直接使用<code>DexClassLoader</code>进行加载就可以么，很显然不行，还是会报异常</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">DexClassLoader加载的类是没有组件生命周期的，即DexClassLoader即使通过对APK的动态加载完成了对组件类的加载，当系统启动该组件时，依然会出现加载类失败的异常<br></code></pre></td></tr></table></figure><p>所以我们要想使用DexClassLoader进行动态加载dex，我们需要进行类加载器的修正</p><p>当前实现类加载器的修正，主要有两种方案：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">（<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>）替换系统组件类加载器为我们的DexClassLoader，同时设置DexClassLoader的parent为系统组件加载器<span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">2</span><span class="hljs-string">``</span>）打破原有的双亲委派关系，在系统组件类加载器PathClassLoader和BootClassLoader的中间插入我们自己的DexClassLoader<br></code></pre></td></tr></table></figure><h5 id="类加载器替换"><a href="#类加载器替换" class="headerlink" title="&lt;1&gt;类加载器替换"></a>&lt;1&gt;类加载器替换</h5><p>怎么去替换系统的类加载器了，这就和我们上面分析的ActivityThread中<code>LoadedApk</code>有关了，<code>LoadedApk</code>主要负责加载一个Apk程序，我们进一步分析源码</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_JJ9JWN6TTTSNK7B.png" alt="image-20220612190524422"></p><p>很明显，我们可以想到我们通过反射获取mclassLoader，然后使用我们的DexClassLoader进行替换，不就可以成功的让DexClassLoader拥有生命周期了么</p><p>源码实现：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript">总结：<span class="hljs-string">``</span>  <span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>）获取<span class="hljs-title class_">ActivityThread</span>实例<span class="hljs-string">``</span>  <span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">2</span><span class="hljs-string">``</span>）通过反射获取类加载器<span class="hljs-string">``</span>  <span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">3</span><span class="hljs-string">``</span>）获取<span class="hljs-title class_">LoadedApk</span><span class="hljs-string">``</span>  <span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">4</span><span class="hljs-string">``</span>）获取mClassLoader系统类加载器<span class="hljs-string">``</span>  <span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">5</span><span class="hljs-string">``</span>）替换自定义类加载器为系统类加载器<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">replaceClassLoader</span>(<span class="hljs-params">Context context,ClassLoader dexClassLoader</span>)&#123;<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-title class_">ClassLoader</span> pathClassLoader <span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-title class_">MainActivity</span>.<span class="hljs-string">``</span><span class="hljs-keyword">class</span><span class="hljs-string">``</span>.<span class="hljs-title function_">getClassLoader</span>();<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-keyword">try</span><span class="hljs-string">` `</span>&#123;<span class="hljs-string">``</span>      <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-number">1.</span><span class="hljs-string">``</span>获取<span class="hljs-title class_">ActivityThread</span>实例<span class="hljs-string">``</span>      <span class="hljs-string">``</span><span class="hljs-title class_">Class</span> <span class="hljs-title class_">ActivityThread</span> <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>pathClassLoader.<span class="hljs-title function_">loadClass</span>(<span class="hljs-string">``</span><span class="hljs-string">&quot;android.app.ActivityThread&quot;</span><span class="hljs-string">``</span>);<span class="hljs-string">``</span>      <span class="hljs-string">``</span><span class="hljs-title class_">Method</span> currentActivityThread <span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-title class_">ActivityThread</span>.<span class="hljs-title function_">getDeclaredMethod</span>(<span class="hljs-string">``</span><span class="hljs-string">&quot;currentActivityThread&quot;</span><span class="hljs-string">``</span>);<span class="hljs-string">``</span>      <span class="hljs-string">``</span><span class="hljs-title class_">Object</span><span class="hljs-string">` `</span>activityThreadObj <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>currentActivityThread.<span class="hljs-title function_">invoke</span>(<span class="hljs-literal">null</span>);<span class="hljs-string">``</span>      <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-number">2.</span><span class="hljs-string">``</span>通过反射获得类加载器<span class="hljs-string">``</span>      <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>final <span class="hljs-title class_">ArrayMap</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">WeakReference</span>&lt;<span class="hljs-title class_">LoadedApk</span>&gt;&gt; mPackages <span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayMap</span>&lt;&gt;();<span class="hljs-string">``</span>      <span class="hljs-string">``</span><span class="hljs-title class_">Field</span> mPackagesField <span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-title class_">ActivityThread</span>.<span class="hljs-title function_">getDeclaredField</span>(<span class="hljs-string">``</span><span class="hljs-string">&quot;mPackages&quot;</span><span class="hljs-string">``</span>);<span class="hljs-string">``</span>      <span class="hljs-string">``</span>mPackagesField.<span class="hljs-title function_">setAccessible</span>(<span class="hljs-literal">true</span>);<span class="hljs-string">``</span>      <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-number">3.</span><span class="hljs-string">``</span>拿到<span class="hljs-title class_">LoadedApk</span><span class="hljs-string">``</span>      <span class="hljs-string">``</span><span class="hljs-title class_">ArrayMap</span> mPackagesObj <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>(<span class="hljs-title class_">ArrayMap</span>) mPackagesField.<span class="hljs-title function_">get</span>(activityThreadObj);<span class="hljs-string">``</span>      <span class="hljs-string">``</span><span class="hljs-title class_">String</span> packagename <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>context.<span class="hljs-title function_">getPackageName</span>();<span class="hljs-string">``</span>      <span class="hljs-string">``</span><span class="hljs-title class_">WeakReference</span> wr <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>(<span class="hljs-title class_">WeakReference</span>) mPackagesObj.<span class="hljs-title function_">get</span>(packagename);<span class="hljs-string">``</span>      <span class="hljs-string">``</span><span class="hljs-title class_">Object</span><span class="hljs-string">` `</span><span class="hljs-title class_">LoadApkObj</span> <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>wr.<span class="hljs-title function_">get</span>();<span class="hljs-string">``</span>      <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-number">4.</span><span class="hljs-string">``</span>拿到mclassLoader<span class="hljs-string">``</span>      <span class="hljs-string">``</span><span class="hljs-title class_">Class</span> <span class="hljs-title class_">LoadedApkClass</span> <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>pathClassLoader.<span class="hljs-title function_">loadClass</span>(<span class="hljs-string">``</span><span class="hljs-string">&quot;android.app.LoadedApk&quot;</span><span class="hljs-string">``</span>);<span class="hljs-string">``</span>      <span class="hljs-string">``</span><span class="hljs-title class_">Field</span> mClassLoaderField <span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-title class_">LoadedApkClass</span>.<span class="hljs-title function_">getDeclaredField</span>(<span class="hljs-string">``</span><span class="hljs-string">&quot;mClassLoader&quot;</span><span class="hljs-string">``</span>);<span class="hljs-string">``</span>      <span class="hljs-string">``</span>mClassLoaderField.<span class="hljs-title function_">setAccessible</span>(<span class="hljs-literal">true</span>);<span class="hljs-string">``</span>      <span class="hljs-string">``</span><span class="hljs-title class_">Object</span><span class="hljs-string">` `</span>mClassLoader <span class="hljs-string">``</span>=<span class="hljs-string">``</span>mClassLoaderField.<span class="hljs-title function_">get</span>(<span class="hljs-title class_">LoadApkObj</span>);<span class="hljs-string">``</span>      <span class="hljs-string">``</span><span class="hljs-title class_">Log</span>.<span class="hljs-title function_">e</span>(<span class="hljs-string">``</span><span class="hljs-string">&quot;mClassLoader&quot;</span><span class="hljs-string">``</span>,mClassLoader.<span class="hljs-title function_">toString</span>());<span class="hljs-string">``</span>      <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-number">5.</span><span class="hljs-string">``</span>将系统组件<span class="hljs-title class_">ClassLoader</span>给替换<span class="hljs-string">``</span>      <span class="hljs-string">``</span>mClassLoaderField.<span class="hljs-string">``</span>set<span class="hljs-string">``</span>(<span class="hljs-title class_">LoadApkObj</span>,dexClassLoader);<span class="hljs-string">``</span>    <span class="hljs-string">``</span>&#125;<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-keyword">catch</span> (<span class="hljs-title class_">ClassNotFoundException</span> e) &#123;<span class="hljs-string">``</span>      <span class="hljs-string">``</span>e.<span class="hljs-title function_">printStackTrace</span>();<span class="hljs-string">``</span>    <span class="hljs-string">``</span>&#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">NoSuchMethodException</span> e) &#123;<span class="hljs-string">``</span>      <span class="hljs-string">``</span>e.<span class="hljs-title function_">printStackTrace</span>();<span class="hljs-string">``</span>    <span class="hljs-string">``</span>&#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">IllegalAccessException</span> e) &#123;<span class="hljs-string">``</span>      <span class="hljs-string">``</span>e.<span class="hljs-title function_">printStackTrace</span>();<span class="hljs-string">``</span>    <span class="hljs-string">``</span>&#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">InvocationTargetException</span> e) &#123;<span class="hljs-string">``</span>      <span class="hljs-string">``</span>e.<span class="hljs-title function_">printStackTrace</span>();<span class="hljs-string">``</span>    <span class="hljs-string">``</span>&#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">NoSuchFieldException</span> e) &#123;<span class="hljs-string">``</span>      <span class="hljs-string">``</span>e.<span class="hljs-title function_">printStackTrace</span>();<span class="hljs-string">``</span>    <span class="hljs-string">``</span>&#125;<span class="hljs-string">``</span>  <span class="hljs-string">``</span>&#125;<br></code></pre></td></tr></table></figure><p>显示详细信息</p><h5 id="类加载器插入"><a href="#类加载器插入" class="headerlink" title="&lt;2&gt;类加载器插入"></a>&lt;2&gt;类加载器插入</h5><p>还有一种方案，动态加载中我们讲述了类加载器的双亲委派机制，就是说我们的类加载器刚拿到类，并不会直接进行加载，而是先判断自己是否加载，如果没有加载则给自己的父类，父类再给父类，所以我们让DexClassLoader成为PathClassLoader的父类，这样就可以解决DexClassLoader生命周期的问题</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">总结：<span class="hljs-string">``</span>  <span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>）将DexClassloader父节点设置为BootClassLoader<span class="hljs-string">``</span>  <span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">2</span><span class="hljs-string">``</span>）将PathClassLoader父节点设置为DexClassloader<br></code></pre></td></tr></table></figure><p>代码实现：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">replaceClassLoader</span>(<span class="hljs-params">Context context, ClassLoader dexClassLoader</span>)&#123;<span class="hljs-string">``</span>    <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>将pathClassLoader父节点设置为<span class="hljs-title class_">DexClassLoader</span><span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-title class_">ClassLoader</span> pathClassLoaderobj <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>context.<span class="hljs-title function_">getClassLoader</span>();<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-title class_">Class</span>&lt;<span class="hljs-title class_">ClassLoader</span>&gt; <span class="hljs-title class_">ClassLoaderClass</span> <span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-title class_">ClassLoader</span>.<span class="hljs-string">``</span><span class="hljs-keyword">class</span><span class="hljs-string">``</span>;<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-keyword">try</span><span class="hljs-string">` `</span>&#123;<span class="hljs-string">``</span>      <span class="hljs-string">``</span><span class="hljs-title class_">Field</span> parent <span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-title class_">ClassLoaderClass</span>.<span class="hljs-title function_">getDeclaredField</span>(<span class="hljs-string">``</span><span class="hljs-string">&quot;parent&quot;</span><span class="hljs-string">``</span>);<span class="hljs-string">``</span>      <span class="hljs-string">``</span>parent.<span class="hljs-title function_">setAccessible</span>(<span class="hljs-literal">true</span>);<span class="hljs-string">``</span>      <span class="hljs-string">``</span>parent.<span class="hljs-string">``</span>set<span class="hljs-string">``</span>(pathClassLoaderobj,dexClassLoader);<span class="hljs-string">``</span>    <span class="hljs-string">``</span>&#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">NoSuchFieldException</span> e) &#123;<span class="hljs-string">``</span>      <span class="hljs-string">``</span>e.<span class="hljs-title function_">printStackTrace</span>();<span class="hljs-string">``</span>    <span class="hljs-string">``</span>&#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">IllegalAccessException</span> e) &#123;<span class="hljs-string">``</span>      <span class="hljs-string">``</span>e.<span class="hljs-title function_">printStackTrace</span>();<span class="hljs-string">``</span>    <span class="hljs-string">``</span>&#125;<span class="hljs-string">` `</span>  <span class="hljs-string">``</span>&#125;<br></code></pre></td></tr></table></figure><p>显示详细信息</p><p>完成壳加载器的修正后，我们就可以正常的加载dex了</p><h2 id="三、整体加壳案例实现"><a href="#三、整体加壳案例实现" class="headerlink" title="三、整体加壳案例实现"></a>三、整体加壳案例实现</h2><p>前面我们详细讲述了App运行机制和整体加壳的实现机制，下面我们就按照前面的讲述，来实现一个简单的整体加壳案例</p><p>实验准备：</p><h3 id="1-编写源程序"><a href="#1-编写源程序" class="headerlink" title="1.编写源程序"></a>1.编写源程序</h3><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_BGVUCTN729TS33A.png" alt="image-20220612193114397"></p><p>这就是我们的源程序，源程序运行，我们会在日志中看见我们打印的信息，然后我们生成dex文件</p><h3 id="2-编写壳程序"><a href="#2-编写壳程序" class="headerlink" title="2.编写壳程序"></a>2.编写壳程序</h3><h4 id="（1）准备工作"><a href="#（1）准备工作" class="headerlink" title="（1）准备工作"></a>（1）准备工作</h4><p>将dex文件上传sdcard，并给应用设置存储权限</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_RMV5QQYXEF36SBK.png" alt="image-20220612195812601"></p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_DRNGWY7PATAJEHV.png" alt="image-20220612200126917"></p><h4 id="（2）编写代理类"><a href="#（2）编写代理类" class="headerlink" title="（2）编写代理类"></a>（2）编写代理类</h4><p>我们首先编写代理类，模仿上面的加壳应用</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_NGQ2BP6G5EZSW4R.png" alt="image-20220612193735398"></p><p>然后我们设置AndroidManifest.xml中的代理类别</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_KVCWJ6Y8NCNNZQD.png" alt="image-20220612193921062"></p><p>然后我们选择在attachBaseContext或onCreate中对我们的dex进行动态加载和类加载器修正即可，因为这里我们源dex并未进行加密，所以也无需解密的过程</p><p>然后加入导入类的Activity</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_NZVVEC54DSPPQWH.png" alt="image-20220612215843088"></p><h4 id="（3）动态加载"><a href="#（3）动态加载" class="headerlink" title="（3）动态加载"></a>（3）动态加载</h4><p>我们进行动态加载classes.dex</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_P3EBC5G3DZGYMBC.png" alt="image-20220612200319851"></p><p>然后使用上面的一种方法进行类加载器修正</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_CHTX8YDZT9D6FCZ.png" alt="image-20220612215713138"></p><p>然后运行</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_8Q6V9G5SYB84HTH.png" alt="image-20220612215745595"></p><p>运行成功，说明我们的整体加壳成功</p><h2 id="四、脱壳点相关概念详解"><a href="#四、脱壳点相关概念详解" class="headerlink" title="四、脱壳点相关概念详解"></a>四、脱壳点相关概念详解</h2><p>上面我们已经理解了APP加壳的基本原理，下面我们进一步来学习如何进行脱壳，Android APP脱壳绕不开<code>DexFile</code>、<code>ArtMethod</code>两个概念，这两个在脱壳中扮演的至关重要的地位，无数的脱壳点都是从其演变而来。</p><h3 id="1-Dex加载流程"><a href="#1-Dex加载流程" class="headerlink" title="1.Dex加载流程"></a>1.Dex加载流程</h3><p>我们在分析脱壳点过程中，首先就需要明白Dex加载的基本流程</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_EW57N5TGBD9XNPJ.png" alt="image-20220612215745595"></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">DexPathList:该类主要用来查找Dex、SO库的路径，并这些路径整体呈一个数组<span class="hljs-string">``</span>Element:根据多路径的分隔符“;”将dexPath转换成<span class="hljs-string">``</span>File<span class="hljs-string">``</span>列表，记录所有的dexFile<span class="hljs-string">``</span>DexFile:用来描述Dex文件，Dex的加载以及Class的查找都是由该类调用它的native方法完成的<br></code></pre></td></tr></table></figure><p>我们依次来分析这个过程中的源码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">DexPathList</span><br>/<span class="hljs-string">``</span>libcore<span class="hljs-string">``</span>/<span class="hljs-string">``</span>dalvik<span class="hljs-string">``</span>/<span class="hljs-string">``</span>src<span class="hljs-string">``</span>/<span class="hljs-string">``</span>main<span class="hljs-string">``</span>/<span class="hljs-string">``</span>java<span class="hljs-string">``</span>/<span class="hljs-string">``</span>dalvik<span class="hljs-string">``</span>/<span class="hljs-string">``</span>system<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-title class_">DexPathList</span>.<span class="hljs-property">java</span><span class="hljs-string">``</span><span class="hljs-keyword">public</span> <span class="hljs-title class_">DexPathList</span>(<span class="hljs-title class_">ClassLoader</span> definingContext, <span class="hljs-title class_">String</span> dexPath,<span class="hljs-string">``</span>      <span class="hljs-string">``</span><span class="hljs-title class_">String</span> librarySearchPath, <span class="hljs-string">``</span><span class="hljs-title class_">File</span><span class="hljs-string">` `</span>optimizedDirectory) &#123;<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">`   `</span>  <span class="hljs-string">``</span><span class="hljs-variable language_">this</span>.<span class="hljs-property">dexElements</span> <span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-title function_">makeDexElements</span>(<span class="hljs-title function_">splitDexPath</span>(dexPath), optimizedDirectory,<span class="hljs-string">``</span>                     <span class="hljs-string">``</span>suppressedExceptions, definingContext);  <span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">` `</span>      <span class="hljs-string">``</span>&#125;<br>makeDexElements<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">Element</span>[] <span class="hljs-title function_">makeDexElements</span>(<span class="hljs-params"><span class="hljs-string">``</span>List<span class="hljs-string">``</span>&lt;<span class="hljs-string">``</span>File<span class="hljs-string">``</span>&gt; files, <span class="hljs-string">``</span>File<span class="hljs-string">` `</span>optimizedDirectory,<span class="hljs-string">``</span>     <span class="hljs-string">``</span>List<span class="hljs-string">``</span>&lt;IOException&gt; suppressedExceptions, ClassLoader loader</span>) &#123;<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">`      `</span>    <span class="hljs-string">``</span><span class="hljs-title class_">DexFile</span> dex <span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-title function_">loadDexFile</span>(<span class="hljs-string">``</span>file<span class="hljs-string">``</span>, optimizedDirectory, loader, elements);  <span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">`    `</span>     <span class="hljs-string">``</span>&#125;<br>loadDexFile<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">DexFile</span> <span class="hljs-title function_">loadDexFile</span>(<span class="hljs-string">``</span><span class="hljs-title class_">File</span><span class="hljs-string">` `</span>file<span class="hljs-string">``</span>, <span class="hljs-string">``</span><span class="hljs-title class_">File</span><span class="hljs-string">` `</span>optimizedDirectory, <span class="hljs-title class_">ClassLoader</span> loader,<span class="hljs-string">``</span>                    <span class="hljs-string">``</span><span class="hljs-title class_">Element</span>[] elements)<span class="hljs-string">``</span>      <span class="hljs-string">``</span>throws <span class="hljs-title class_">IOException</span> &#123;<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-keyword">if</span><span class="hljs-string">` `</span>(optimizedDirectory <span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-literal">null</span>) &#123;<span class="hljs-string">``</span>      <span class="hljs-string">``</span><span class="hljs-keyword">return</span><span class="hljs-string">` `</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">DexFile</span>(<span class="hljs-string">``</span>file<span class="hljs-string">``</span>, loader, elements);<span class="hljs-string">``</span>    <span class="hljs-string">``</span>&#125; <span class="hljs-string">``</span><span class="hljs-keyword">else</span><span class="hljs-string">` `</span>&#123;<span class="hljs-string">``</span>      <span class="hljs-string">``</span><span class="hljs-title class_">String</span> optimizedPath <span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-title function_">optimizedPathFor</span>(<span class="hljs-string">``</span>file<span class="hljs-string">``</span>, optimizedDirectory);<span class="hljs-string">``</span>      <span class="hljs-string">``</span><span class="hljs-keyword">return</span><span class="hljs-string">` `</span><span class="hljs-title class_">DexFile</span>.<span class="hljs-title function_">loadDex</span>(<span class="hljs-string">``</span>file<span class="hljs-string">``</span>.<span class="hljs-title function_">getPath</span>(), optimizedPath, <span class="hljs-string">``</span><span class="hljs-number">0</span><span class="hljs-string">``</span>, loader, elements);<span class="hljs-string">``</span>    <span class="hljs-string">``</span>&#125;<span class="hljs-string">``</span>  <span class="hljs-string">``</span>&#125;<br>loadDex<br><span class="hljs-keyword">static</span> <span class="hljs-title class_">DexFile</span> <span class="hljs-title function_">loadDex</span>(<span class="hljs-title class_">String</span> sourcePathName, <span class="hljs-title class_">String</span> outputPathName,<span class="hljs-string">``</span>   <span class="hljs-string">``</span>int<span class="hljs-string">` `</span>flags, <span class="hljs-title class_">ClassLoader</span> loader, <span class="hljs-title class_">DexPathList</span>.<span class="hljs-property">Element</span>[] elements) throws <span class="hljs-title class_">IOException</span> &#123;<span class="hljs-string">``</span>   <span class="hljs-string">``</span><span class="hljs-keyword">return</span><span class="hljs-string">` `</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">DexFile</span>(sourcePathName, outputPathName, flags, loader, elements);<span class="hljs-string">``</span> <span class="hljs-string">``</span>&#125;<br><span class="hljs-title class_">DexFile</span><br>/<span class="hljs-string">``</span>libcore<span class="hljs-string">``</span>/<span class="hljs-string">``</span>dalvik<span class="hljs-string">``</span>/<span class="hljs-string">``</span>src<span class="hljs-string">``</span>/<span class="hljs-string">``</span>main<span class="hljs-string">``</span>/<span class="hljs-string">``</span>java<span class="hljs-string">``</span>/<span class="hljs-string">``</span>dalvik<span class="hljs-string">``</span>/<span class="hljs-string">``</span>system<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-title class_">DexFile</span>.<span class="hljs-property">java</span><span class="hljs-string">``</span><span class="hljs-title class_">DexFile</span>(<span class="hljs-title class_">String</span> fileName, <span class="hljs-title class_">ClassLoader</span> loader, <span class="hljs-title class_">DexPathList</span>.<span class="hljs-property">Element</span>[] elements) throws <span class="hljs-title class_">IOException</span> &#123;<span class="hljs-string">``</span>    <span class="hljs-string">``</span>mCookie <span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-title function_">openDexFile</span>(fileName, <span class="hljs-literal">null</span>, <span class="hljs-string">``</span><span class="hljs-number">0</span><span class="hljs-string">``</span>, loader, elements);<span class="hljs-string">``</span>    <span class="hljs-string">``</span>mInternalCookie <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>mCookie;<span class="hljs-string">``</span>    <span class="hljs-string">``</span>mFileName <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>fileName;<span class="hljs-string">``</span>    <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">``</span><span class="hljs-string">&quot;DEX FILE cookie is &quot;</span><span class="hljs-string">` `</span>+<span class="hljs-string">` `</span>mCookie <span class="hljs-string">``</span>+<span class="hljs-string">` `</span><span class="hljs-string">&quot; fileName=&quot;</span><span class="hljs-string">` `</span>+<span class="hljs-string">` `</span>fileName);<span class="hljs-string">``</span>  <span class="hljs-string">``</span>&#125;<br></code></pre></td></tr></table></figure><p>这里出现的mCookie，mCookie在C&#x2F;C++层中是DexFile的指针，我们在下面详细讲解</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs qml">openDexFile<br>private static <span class="hljs-string">``</span><span class="hljs-built_in">Object</span><span class="hljs-string">` `</span>openDexFile(<span class="hljs-built_in">String</span> sourceName, <span class="hljs-built_in">String</span> outputName, <span class="hljs-string">``</span><span class="hljs-built_in">int</span><span class="hljs-string">` `</span>flags,<span class="hljs-string">``</span>    <span class="hljs-string">``</span>ClassLoader loader, DexPathList.Element[] elements) throws <span class="hljs-title">IOException</span> &#123;<span class="hljs-string">``</span>    <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">` `</span>Use absolute paths to enable the use <span class="hljs-keyword">of</span> relative paths when testing <span class="hljs-keyword">on</span> host.<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-keyword">return</span><span class="hljs-string">` `</span>openDexFileNative(<span class="hljs-keyword">new</span> <span class="hljs-string">``</span>File<span class="hljs-string">``</span>(sourceName).getAbsolutePath(),<span class="hljs-string">``</span>                 <span class="hljs-string">``</span>(outputName <span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-literal">null</span>)<span class="hljs-string">``</span>                  <span class="hljs-string">``</span>? <span class="hljs-literal">null</span><span class="hljs-string">``</span>                  <span class="hljs-string">``</span>: <span class="hljs-keyword">new</span> <span class="hljs-string">``</span>File<span class="hljs-string">``</span>(outputName).getAbsolutePath(),<span class="hljs-string">``</span>                   <span class="hljs-string">``</span>flags,<span class="hljs-string">``</span>                  <span class="hljs-string">``</span>loader,<span class="hljs-string">``</span>                  <span class="hljs-string">``</span>elements);<span class="hljs-string">``</span>  <span class="hljs-string">``</span>&#125;<br></code></pre></td></tr></table></figure><p>显示详细信息</p><p>这里就进入了C&#x2F;C++层</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">openDexFileNative</span><br></code></pre></td></tr></table></figure><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_G7H6JPREYMZ8XN4.png" alt="image-20220613134340460"></p><p>为了节约篇幅，我们快速分析，中间再经过一些函数</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">OpenDexFilesFromOat</span>()``<span class="hljs-built_in">MakeUpToDate</span>()``<span class="hljs-built_in">GenerateOatFileNoChecks</span>()``<span class="hljs-built_in">Dex2Oat</span>()<br></code></pre></td></tr></table></figure><p>最后进进入了Dex2Oat，这就进入了Dex2Oat的编译流程</p><p>反之如果我们在下面Dex2Oat的流程中通过Hook相关方法或execv或execve导致dex2oat失败，我们就会返回到<code>OpenDexFilesFromOat</code></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">OpenDexFilesFromOat</span><br></code></pre></td></tr></table></figure><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_9ZEY5KR5Q6ESSF7.png" alt="image-20220613145156590"></p><p>会先在<code>HasOriginalDexFiles</code>里尝试加载我们的Dex，也就是说，倘若我们的壳阻断了dex2oat的编译流程，然后又调用了DexFile的Open函数。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">DexFile::Open<br></code></pre></td></tr></table></figure><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_7H83UJ6WPGBQWZJ.png" alt="image-20220613145606897"></p><p>校验dex的魔术字字段，然后调用<code>DexFile::OpenFile</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">DexFile::OpenFile<br>/<span class="hljs-string">``</span>art<span class="hljs-string">``</span>/<span class="hljs-string">``</span>runtime<span class="hljs-string">``</span>/<span class="hljs-string">``</span>dex_file.cc<span class="hljs-string">``</span>std::unique_ptr&lt;<span class="hljs-keyword">const</span> DexFile&gt; DexFile::OpenFile(<span class="hljs-string">``</span><span class="hljs-type">int</span><span class="hljs-string">` `</span>fd,<span class="hljs-string">``</span>                        <span class="hljs-string">``</span><span class="hljs-keyword">const</span> std::<span class="hljs-type">string</span>&amp; location,<span class="hljs-string">``</span>                        <span class="hljs-string">``</span><span class="hljs-type">bool</span><span class="hljs-string">` `</span>verify,<span class="hljs-string">``</span>                        <span class="hljs-string">``</span><span class="hljs-type">bool</span><span class="hljs-string">` `</span>verify_checksum,<span class="hljs-string">``</span>                        <span class="hljs-string">``</span>std::<span class="hljs-type">string</span><span class="hljs-string">``</span>*<span class="hljs-string">` `</span>error_msg) &#123;<span class="hljs-string">``</span> <span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span> <span class="hljs-string">``</span>std::unique_ptr&lt;DexFile&gt; dex_file <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>OpenCommon(<span class="hljs-string">``</span><span class="hljs-keyword">map</span><span class="hljs-string">``</span>-<span class="hljs-string">``</span>&gt;Begin(),<span class="hljs-string">``</span>                        <span class="hljs-string">``</span><span class="hljs-keyword">map</span><span class="hljs-string">``</span>-<span class="hljs-string">``</span>&gt;Size(),<span class="hljs-string">``</span>                        <span class="hljs-string">``</span>location,<span class="hljs-string">``</span>                        <span class="hljs-string">``</span>dex_header<span class="hljs-string">``</span>-<span class="hljs-string">``</span>&gt;checksum_,<span class="hljs-string">``</span>                        <span class="hljs-string">``</span>kNoOatDexFile,<span class="hljs-string">``</span>                        <span class="hljs-string">``</span>verify,<span class="hljs-string">``</span>                        <span class="hljs-string">``</span>verify_checksum,<span class="hljs-string">``</span>                        <span class="hljs-string">``</span>error_msg); <span class="hljs-string">``</span> <span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">` `</span>                        <span class="hljs-string">``</span>&#125;<br></code></pre></td></tr></table></figure><p>显示详细信息</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">OpenCommon</span><br></code></pre></td></tr></table></figure><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_E2VAW4SHZENYAGQ.png" alt="image-20220613145950224"></p><p>最后又再次回到<code>DexFile</code>类，这里我们的dex文件加载基本流程分析完毕</p><h3 id="2-Dex2Oat编译流程"><a href="#2-Dex2Oat编译流程" class="headerlink" title="2.Dex2Oat编译流程"></a>2.Dex2Oat编译流程</h3><p>Dex2oat是google公司为了提高编译效率的一种机制，从Android8.0开始实施，一些加壳厂商实现抽取壳往往会禁用Dex2oat，而针对整体加壳没有禁用的Dex2Oat也成为了脱壳点</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_ZKW5FV6YD4JW9JF.png" alt="image-20220613134904994"></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-title class_">Exec</span><br>/<span class="hljs-string">``</span>art<span class="hljs-string">``</span>/<span class="hljs-string">``</span>runtime<span class="hljs-string">``</span>/<span class="hljs-string">``</span>exec_utils.cc<span class="hljs-string">``</span>bool<span class="hljs-string">` `</span><span class="hljs-title class_">Exec</span>(std::vector&lt;std::string&gt;&amp; arg_vector, std::string<span class="hljs-string">``</span>*<span class="hljs-string">` `</span>error_msg) &#123;<span class="hljs-string">``</span> <span class="hljs-string">``</span>int<span class="hljs-string">` `</span>status <span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-title class_">ExecAndReturnCode</span>(arg_vector, error_msg);<span class="hljs-string">``</span> <span class="hljs-string">``</span><span class="hljs-keyword">if</span><span class="hljs-string">` `</span>(status !<span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-number">0</span><span class="hljs-string">``</span>) &#123;<span class="hljs-string">``</span>  <span class="hljs-string">``</span>const std::string command_line(android::base::<span class="hljs-title class_">Join</span>(arg_vector, <span class="hljs-string">``</span><span class="hljs-string">&#x27; &#x27;</span><span class="hljs-string">``</span>));<span class="hljs-string">``</span>  <span class="hljs-string">``</span>*<span class="hljs-string">``</span>error_msg <span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-title class_">StringPrintf</span>(<span class="hljs-string">``</span><span class="hljs-string">&quot;Failed execv(%s) because non-0 exit status&quot;</span><span class="hljs-string">``</span>,<span class="hljs-string">``</span>               <span class="hljs-string">``</span>command_line.c_str());<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-keyword">return</span><span class="hljs-string">` `</span><span class="hljs-literal">false</span>;<span class="hljs-string">``</span> <span class="hljs-string">``</span>&#125;<span class="hljs-string">``</span> <span class="hljs-string">``</span><span class="hljs-keyword">return</span><span class="hljs-string">` `</span><span class="hljs-literal">true</span>;<span class="hljs-string">``</span>&#125;<br><span class="hljs-title class_">ExecAndReturnCode</span><br></code></pre></td></tr></table></figure><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_A77NRB57ZAFQU8A.png" alt="image-20220613143206138"></p><p>而我们就可以通过Hook execv或execve来禁用Dex2Oat，而如果我们不禁用dex2oat，<em>execve函数</em>是用来调用<code>dex2oat</code>的二进制程序实现对dex文件的加载，我们这时候找到<code>dex2oat.cc</code>这个文件，找到main函数</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs d">/<span class="hljs-string">``</span>art<span class="hljs-string">``</span>/<span class="hljs-string">``d</span>ex2oat<span class="hljs-string">``</span>/<span class="hljs-string">``d</span>ex2oat.cc<span class="hljs-string">``</span> <span class="hljs-string">``</span><span class="hljs-keyword">int</span><span class="hljs-string">` `</span>main(<span class="hljs-string">``</span><span class="hljs-keyword">int</span><span class="hljs-string">` `</span>argc, <span class="hljs-built_in">char</span><span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">` `</span>argv) &#123;<span class="hljs-string">``</span> <span class="hljs-string">``</span><span class="hljs-keyword">int</span><span class="hljs-string">` `</span>result <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>static_cast&lt;<span class="hljs-string">``</span><span class="hljs-keyword">int</span><span class="hljs-string">``</span>&gt;(art::Dex2oat(argc, argv));<span class="hljs-string">``</span> <span class="hljs-string">``</span><span class="hljs-keyword">if</span><span class="hljs-string">` `</span>(!art::kIsDebugBuild &amp;&amp; (RUNNING_ON_MEMORY_TOOL <span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-number">0</span><span class="hljs-string">``</span>)) &#123;<span class="hljs-string">``</span>  <span class="hljs-string">``</span>_exit(result);<span class="hljs-string">``</span> <span class="hljs-string">``</span>&#125;<span class="hljs-string">``</span> <span class="hljs-string">``</span><span class="hljs-keyword">return</span><span class="hljs-string">` `</span>result;<br></code></pre></td></tr></table></figure><p>这里我们调用了Dex2oat</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs d">Dex2Oat<br>/<span class="hljs-string">``</span>art<span class="hljs-string">``</span>/<span class="hljs-string">``d</span>ex2oat<span class="hljs-string">``</span>/<span class="hljs-string">``d</span>ex2oat.cc<span class="hljs-string">``</span><span class="hljs-keyword">static</span> dex2oat::ReturnCode Dex2oat(<span class="hljs-string">``</span><span class="hljs-keyword">int</span><span class="hljs-string">` `</span>argc, <span class="hljs-built_in">char</span><span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">` `</span>argv) &#123;<span class="hljs-string">``</span>  <span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>  <span class="hljs-string">``d</span>ex2oat::ReturnCode setup_code <span class="hljs-string">``</span>=<span class="hljs-string">` `d</span>ex2oat<span class="hljs-string">``</span>-<span class="hljs-string">``</span>&gt;Setup();<span class="hljs-string">``</span>  <span class="hljs-string">``d</span>ex2oat::ReturnCode result;<span class="hljs-string">``</span> <span class="hljs-string">``</span><span class="hljs-keyword">if</span><span class="hljs-string">` `</span>(dex2oat<span class="hljs-string">``</span>-<span class="hljs-string">``</span>&gt;IsImage()) &#123;<span class="hljs-string">``</span>  <span class="hljs-string">``</span>result <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>CompileImage(<span class="hljs-string">``</span>*<span class="hljs-string">``d</span>ex2oat);<span class="hljs-string">``</span> <span class="hljs-string">``</span>&#125; <span class="hljs-string">``</span><span class="hljs-keyword">else</span><span class="hljs-string">` `</span>&#123;<span class="hljs-string">``</span>  <span class="hljs-string">``</span>result <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>CompileApp(<span class="hljs-string">``</span>*<span class="hljs-string">``d</span>ex2oat);<span class="hljs-string">``</span> <span class="hljs-string">``</span>&#125;<span class="hljs-string">``</span>  <span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>&#125;<br></code></pre></td></tr></table></figure><p>显示详细信息</p><p>Dex2oat中会对dex文件进行逐个类逐个函数的编译，setup()函数完成对dex的加载</p><p>然后顺序执行，就会进入<code>CompileApp</code></p><p>编译过程中会按照逐个函数进行编译，就会进入<code>CompileMethod</code></p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_4H5QGXPPAQ9H6MM.png" alt="image-20220613151229524"></p><p>到这里Dex2oat的基本流程就分析完毕</p><h3 id="3-类加载流程"><a href="#3-类加载流程" class="headerlink" title="3.类加载流程"></a>3.类加载流程</h3><p>要理解DexFile为什么如此重要，首先我们要清除Android APP的类加载流程。Android的类加载一般分为两类<code>隐式加载</code>和<code>显式加载</code></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-number">1.</span><span class="hljs-string">``</span>隐式加载:<span class="hljs-string">``</span>  <span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>)创建类的实例,也就是<span class="hljs-keyword">new</span>一个对象<span class="hljs-string">``</span>  <span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-number">2</span><span class="hljs-string">``</span>)访问某个类或接口的静态变量,或者对该静态变量赋值<span class="hljs-string">``</span>  <span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-number">3</span><span class="hljs-string">``</span>)调用类的静态方法<span class="hljs-string">``</span>  <span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-number">4</span><span class="hljs-string">``</span>)反射Class.forName(<span class="hljs-string">``</span><span class="hljs-string">&quot;android.app.ActivityThread&quot;</span><span class="hljs-string">``</span>)<span class="hljs-string">``</span>  <span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-number">5</span><span class="hljs-string">``</span>)初始化一个类的子类(会首先初始化子类的父类)<span class="hljs-string">``</span><span class="hljs-number">2.</span><span class="hljs-string">``</span>显示加载：<span class="hljs-string">``</span>  <span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>)使用LoadClass()加载<span class="hljs-string">``</span>  <span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-number">2</span><span class="hljs-string">``</span>)使用forName()加载<br></code></pre></td></tr></table></figure><p>我们详细看一下显示加载：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">Class.forName 和 ClassLoader.loadClass加载有何不同：<span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>）ClassLoader.loadClass也能加载一个类,但是不会触发类的初始化(也就是说不会对类的静态变量,静态代码块进行初始化操作)<span class="hljs-string">``</span>（<span class="hljs-string">``</span><span class="hljs-number">2</span><span class="hljs-string">``</span>）Class.forName这种方式,不但会加载一个类,还会触发类的初始化阶段,也能够为这个类的静态变量,静态代码块进行初始化操作<br></code></pre></td></tr></table></figure><p>我们在详细来看一下在类加载过程中的流程：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">java层<br></code></pre></td></tr></table></figure><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_BTCHHBZVJNJQJWV.png" alt="image-20220612215745595"></p><p>我们可以发现类加载中关键的DexFile，该类用来描述Dex文件，所以我们的脱壳对象就是<code>DexFile</code></p><p>这里从DexFile进入Native层中，还有一个关键的字段就是<code>mCookie</code></p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_MVB7WZJNEG6MBGK.png" alt="image-20220613102141423"></p><p>后面我们详细的介绍<code>mCookie</code>的作用</p><p>我们进一步分析，进入Native层</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">Native</span>层<br></code></pre></td></tr></table></figure><p>&#x2F;art&#x2F;runtime&#x2F;native&#x2F;[dalvik_system_DexFile.cc</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_5Z5RGDXNJ5ZW7NE.png" alt="image-20220613124716608"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">ConvertJavaArrayToDexFiles对cookie进行了处理<br></code></pre></td></tr></table></figure><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_S4UPYX5XB7NCVPY.png" alt="image-20220613125016884"></p><p>通过这里的分析，我们可以知道mCooike转换为C&#x2F;C++层指针后，就是dexfile的索引</p><p>我们继续分析<code>DefineClass</code></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">art<span class="hljs-string">``</span>/<span class="hljs-string">``</span>runtime<span class="hljs-string">``</span>/<span class="hljs-string">``</span>class_linker.cc<span class="hljs-string">``</span>mirror<span class="hljs-type">::Class</span><span class="hljs-string">``</span>*<span class="hljs-string">` `</span>ClassLinker<span class="hljs-type">::DefineClass</span>(<span class="hljs-keyword">Thread</span><span class="hljs-string">``</span>*<span class="hljs-string">` `</span><span class="hljs-built_in">self</span><span class="hljs-string">``</span>,<span class="hljs-string">``</span>                   <span class="hljs-string">``</span>const char<span class="hljs-string">``</span>*<span class="hljs-string">` `</span>descriptor,<span class="hljs-string">``</span>                    <span class="hljs-string">``</span>size_t <span class="hljs-string">``</span>hash<span class="hljs-string">``</span>,<span class="hljs-string">``</span>                    <span class="hljs-string">``</span><span class="hljs-keyword">Handle</span>&lt;mirror<span class="hljs-type">::ClassLoader</span>&gt; class_loader,<span class="hljs-string">``</span>                    <span class="hljs-string">``</span>const DexFile&amp; dex_file,<span class="hljs-string">``</span>                    <span class="hljs-string">``</span>const DexFile<span class="hljs-type">::ClassDef</span>&amp; dex_class_def) &#123;<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>LoadClass(<span class="hljs-string">``</span><span class="hljs-built_in">self</span><span class="hljs-string">``</span>, <span class="hljs-string">``</span>*<span class="hljs-string">``</span>new_dex_file, <span class="hljs-string">``</span>*<span class="hljs-string">``</span>new_class_def, klass);<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>&#125;<br></code></pre></td></tr></table></figure><p>显示详细信息</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lasso">LoadClass<br>art<span class="hljs-string">``</span>/<span class="hljs-string">``</span>runtime<span class="hljs-string">``</span>/<span class="hljs-string">``</span>class_linker.cc<span class="hljs-string">``</span><span class="hljs-literal">void</span> ClassLinker<span class="hljs-type">::LoadClass</span>(<span class="hljs-keyword">Thread</span><span class="hljs-string">``</span>*<span class="hljs-string">` `</span><span class="hljs-built_in">self</span><span class="hljs-string">``</span>,<span class="hljs-string">``</span><span class="hljs-number">3120</span><span class="hljs-string">`              `</span>const DexFile&amp; dex_file,<span class="hljs-string">``</span><span class="hljs-number">3121</span><span class="hljs-string">`              `</span>const DexFile<span class="hljs-type">::ClassDef</span>&amp; dex_class_def,<span class="hljs-string">``</span><span class="hljs-number">3122</span><span class="hljs-string">`              `</span><span class="hljs-keyword">Handle</span>&lt;mirror<span class="hljs-type">::Class</span>&gt; klass) &#123;<span class="hljs-string">``</span><span class="hljs-number">3123</span><span class="hljs-string">` `</span>const uint8_t<span class="hljs-string">``</span>*<span class="hljs-string">` `</span>class_data <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>dex_file.GetClassData(dex_class_def);<span class="hljs-string">``</span><span class="hljs-number">3124</span><span class="hljs-string">` `</span><span class="hljs-keyword">if</span><span class="hljs-string">` `</span>(class_data <span class="hljs-string">``</span>=<span class="hljs-string">``</span>=<span class="hljs-string">` `</span>nullptr) &#123;<span class="hljs-string">``</span><span class="hljs-number">3125</span><span class="hljs-string">`  `</span><span class="hljs-keyword">return</span><span class="hljs-string">``</span>; <span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">` `</span>no fields <span class="hljs-string">``</span><span class="hljs-literal">or</span><span class="hljs-string">` `</span>methods <span class="hljs-string">``</span>-<span class="hljs-string">` `</span>for<span class="hljs-string">` `</span>example a marker interface<span class="hljs-string">``</span><span class="hljs-number">3126</span><span class="hljs-string">` `</span>&#125;<span class="hljs-string">``</span><span class="hljs-number">3127</span><span class="hljs-string">` `</span>LoadClassMembers(<span class="hljs-string">``</span><span class="hljs-built_in">self</span><span class="hljs-string">``</span>, dex_file, class_data, klass);<span class="hljs-string">``</span><span class="hljs-number">3128</span><span class="hljs-string">``</span>&#125;<br>LoadClassMembers<br>art<span class="hljs-string">``</span>/<span class="hljs-string">``</span>runtime<span class="hljs-string">``</span>/<span class="hljs-string">``</span>class_linker.cc<span class="hljs-string">``</span><span class="hljs-literal">void</span> ClassLinker<span class="hljs-type">::LoadClassMembers</span>(<span class="hljs-keyword">Thread</span><span class="hljs-string">``</span>*<span class="hljs-string">` `</span><span class="hljs-built_in">self</span><span class="hljs-string">``</span>,<span class="hljs-string">``</span>                  <span class="hljs-string">``</span>const DexFile&amp; dex_file,<span class="hljs-string">``</span>                  <span class="hljs-string">``</span>const uint8_t<span class="hljs-string">``</span>*<span class="hljs-string">` `</span>class_data,<span class="hljs-string">``</span>                  <span class="hljs-string">``</span><span class="hljs-keyword">Handle</span>&lt;mirror<span class="hljs-type">::Class</span>&gt; klass) &#123;<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>   <span class="hljs-string">``</span>LoadMethod(dex_file, it, klass, method);<span class="hljs-string">``</span>   <span class="hljs-string">``</span>LinkCode(this, method, oat_class_ptr, class_def_method_index);<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>&#125;<br>LoadMethod<br>art<span class="hljs-string">``</span>/<span class="hljs-string">``</span>runtime<span class="hljs-string">``</span>/<span class="hljs-string">``</span>class_linker.cc<span class="hljs-string">``</span><span class="hljs-literal">void</span> ClassLinker<span class="hljs-type">::LoadMethod</span>(const DexFile&amp; dex_file,<span class="hljs-string">``</span>              <span class="hljs-string">``</span>const ClassDataItemIterator&amp; it,<span class="hljs-string">``</span>              <span class="hljs-string">``</span><span class="hljs-keyword">Handle</span>&lt;mirror<span class="hljs-type">::Class</span>&gt; klass,<span class="hljs-string">``</span>               <span class="hljs-string">``</span>ArtMethod<span class="hljs-string">``</span>*<span class="hljs-string">` `</span>dst) &#123;<span class="hljs-string">``</span>&#125;<br>LinkCode<br></code></pre></td></tr></table></figure><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_78UN4BZERGB3BGG.png" alt="image-20220613130149629"></p><p>我们可以发现这里就进入了从linkcode后就进入了解释器中，并对是否进行dex2oat进行了判断，我们直接进入解释器中继续分析</p><p>我们知道Art解释器分为两种：<code>解释模式下</code>和<code>quick模式下</code>，而我们又知道Android8.0开始进行dex2oat</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">如果壳没有禁用dex2oat，那类中的初始化函数运行在解释器模式下<span class="hljs-string">``</span>如果壳禁用dex2oat，dex文件中的所有函数都运行在解释器模式下<span class="hljs-string">``</span>则类的初始化函数运行在解释器模式下<br></code></pre></td></tr></table></figure><p>所以一般的加壳厂商会禁用掉dex2oat，这样可以是所有的函数都运行在解释模式下，所以一些脱壳点选在dex2oat流程中，可能针对禁用dex2oat的情况并不使用，我们这里主要针对整体加壳，就不展开讲述，最后我们得知解释器中会运行在<code>Execute</code>下</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-title class_">Execute</span><br>art<span class="hljs-string">``</span>/<span class="hljs-string">``</span>runtime<span class="hljs-string">``</span>/<span class="hljs-string">``</span>interpreter<span class="hljs-string">``</span>/<span class="hljs-string">``</span>interpreter.cc<span class="hljs-string">``</span>static inline <span class="hljs-title class_">JValue</span> <span class="hljs-title class_">Execute</span>(<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-title class_">Thread</span><span class="hljs-string">``</span>*<span class="hljs-string">` `</span><span class="hljs-variable language_">self</span><span class="hljs-string">``</span>,<span class="hljs-string">``</span>  <span class="hljs-string">``</span>const <span class="hljs-title class_">DexFile</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:CodeItem<span class="hljs-string">``</span>*<span class="hljs-string">` `</span>code_item</span>,<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-title class_">ShadowFrame</span>&amp; shadow_frame,<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-title class_">JValue</span> result_register,<span class="hljs-string">``</span>  <span class="hljs-string">``</span>bool<span class="hljs-string">` `</span>stay_in_interpreter <span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-literal">false</span>) <span class="hljs-variable constant_">REQUIRES_SHARED</span>(<span class="hljs-title class_">Locks</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:mutator_lock_</span>)&#123;<span class="hljs-string">` `</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>   <span class="hljs-string">``</span><span class="hljs-title class_">ArtMethod</span> <span class="hljs-string">``</span>*<span class="hljs-string">``</span>method <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>shadow_frame.<span class="hljs-title class_">GetMethod</span>();<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">``</span>*<span class="hljs-string">` `</span>  <span class="hljs-string">``</span>&#125;<br></code></pre></td></tr></table></figure><p>显示详细信息</p><p>这里我们大致分析完成了类加载的思路</p><h3 id="4-DexFile详解"><a href="#4-DexFile详解" class="headerlink" title="4.DexFile详解"></a>4.DexFile详解</h3><p>前面我们分析了很多，对dex加载、类加载等都已经有了一个很详细的了解，而最终一切的核心就是DexFile，DexFile就是我们脱壳所关注的重点，寒冰大佬在<a href="https://bbs.pediy.com/thread-254555.htm#msg_header_h2_2">拨云见日：安卓APP脱壳的本质以及如何快速发现ART下的脱壳点</a>中提到，在ART下只要获得了DexFile对象，那么我们就可以得到该dex文件在内存中的起始地址和大小，进而完成脱壳。</p><p>我们先查看一些DexFile的结构体</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_Q83V8D5NNXZZHPZ.png" alt="image-20220613152305983"></p><p>只要我们能获得起始地址begin和大小size，就可以成功的将dex文件脱取下来，这里我们记得DexFile含有虚函数表，所以根据C++布局，要偏移一个指针</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_KSHAXGKHDX5SJJ8.png" alt="image-20220613152517629"></p><p>而DexFile类还给我们提供了方便的API</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_7728E3KQDVSZ8K8.png" alt="image-20220613152724888"></p><p>这样只要我们找到函数中有DexFile对象，就可以通过调用API来进一步dump dex文件，由此按照寒冰大佬的思想，大量的脱壳点由此产生</p><h4 id="（1）直接查找法"><a href="#（1）直接查找法" class="headerlink" title="（1）直接查找法"></a>（1）直接查找法</h4><p>我们通过直接在Android源码中搜索DexFile，就可以获得海量的脱壳点</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_M9VA8K6SUMFSAYV.png" alt="image-20220613153036103"></p><p>我们通过在IDA中搜索libart.so导出的DexFile，同样可以获得大量的脱壳点</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_2NU2A86H5SS2EPH.png" alt="image-20220613153220786"></p><h4 id="（2）间接查找法"><a href="#（2）间接查找法" class="headerlink" title="（2）间接查找法"></a>（2）间接查找法</h4><p>这里就是寒冰大佬在文章中提到的通过ArtMethod对象的getDexFile()获取到ArtMethod所属的DexFile对象的这种一级间接法，通过Thread的getCurrentMethod()函数首先获取到ArtMethod或者通过ShadowFrame的getMethod获取到ArtMethod对象，然后再通过getDexFile获取到ArtMethod对象所属的DexFile的二级间接法。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">getDexFile</span>()``<span class="hljs-built_in">getMethod</span>()<br></code></pre></td></tr></table></figure><h3 id="5-ArtMethod详解"><a href="#5-ArtMethod详解" class="headerlink" title="5.ArtMethod详解"></a>5.ArtMethod详解</h3><p>上面我们已经详细分析了DexFile的文件结构，我们知道通过ArtMethod可以获得DexFile，那么为啥又要单独提ArtMethod呢，因为ArtMethod在抽取壳和VMP等壳中扮演了重要的角色</p><p>ArtMethod结构体</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_G5C7AYX3PW2J2ZC.png" alt="image-20220613154044296"></p><p>我们通过ArtMethod可以获得codeitem的偏移和方法索引，熟悉dex结构的朋友知道codeitem就是代码实际的值，而codeitem则再后续加壳技术扮演了至关重要的地址，而且ArtMethod还有非常丰富的方法，可以帮助大家实现很多功能，所以在脱壳工作中也是十分重要的</p><h2 id="五、脱壳技术归纳"><a href="#五、脱壳技术归纳" class="headerlink" title="五、脱壳技术归纳"></a>五、脱壳技术归纳</h2><p>前面分析了很多，最后无非整体加壳的脱壳方案落脚在DexFile的关键对象上，由此产生了一些常用的方法</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_SUNU9THMUQ39Q2K.png" alt="image-20220613154906679"></p><h3 id="1-现有工具脱壳法"><a href="#1-现有工具脱壳法" class="headerlink" title="1.现有工具脱壳法"></a>1.现有工具脱壳法</h3><p>工欲善其事必先利其器，整体加壳已经很多年，不少的大佬们都开发了很多非常好用的工具，我们在自己掌握原理过程时，平时工作中也可以使用很多大佬的开发工具，这里随便举几个自己经常用的工具，这里我对各个大佬的脱壳工具进行了一个梳理</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_P5QAN72MQ58SMKG.png" alt="image-20220613154906679"></p><h4 id="（1）FRIDA-DEXDump"><a href="#（1）FRIDA-DEXDump" class="headerlink" title="（1）FRIDA-DEXDump"></a>（1）FRIDA-DEXDump</h4><p>这是葫芦娃大佬开发的针对整体加壳的工具，主要通过frida技术，文章参考：<a href="https://www.anquanke.com/post/id/221905">深入 FRIDA-DEXDump 中的矛与盾</a>，该工具的特点是一般的hook方案通过直接搜索DEX的头文件dex.035来定位dex的起始地址，但是后来不少公司对头文件的魔术字段进行了抹除，这样针对没有文件头的 <code>DEX</code> 文件，该工具通过map_off 找到 DEX 的 map_list， 通过解析它，并得到类型为 TYPE_MAP_LIST 的条目计算出文件的大小和起始地址，也很好的提供了一种解决思路。</p><p>使用方法：</p><p>FRIDA-DEXDump使用十分的简单，详细参考github：<a href="https://github.com/hluwa/frida-dexdump">FRIDA-DEXDump</a></p><p>这里引用一张大佬星球的使用流程图，非常详细，快速进行脱壳</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_B9QRRUTD84V82ZK.png" alt="image-20220613161015961"></p><p>我们简单演示一下，这里结合objection一起使用</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_CKUHKWSX46DS2N7.png" alt="image-20220613224143108"></p><p>然后再次打开脱下来的dex，即可</p><h4 id="（2）FDex2"><a href="#（2）FDex2" class="headerlink" title="（2）FDex2"></a>（2）FDex2</h4><p>Fdex2主要是利用Android7.0及版本以下的特殊API <code>getDex()</code>来进行脱壳，原本是基于Xposed的模块，不过掌握原理后，大家可以使用各种Hook框架去实现,参考链接：<a href="https://bbs.pediy.com/thread-224105.htm">安卓xposed脱壳工具FDex2</a></p><h4 id="（3）其他工具"><a href="#（3）其他工具" class="headerlink" title="（3）其他工具"></a>（3）其他工具</h4><p>针对整体壳的脱壳工具有很多，无非是针对各种脱壳点再采用不同的方法，其原理是殊途同归，而基于源码定制的Fart、youpk等等针对整体加壳壳都可以基本实现完全的脱壳，而且抽取壳也有着很好的效果，下面我们就依次来讲述具体的脱壳方法原理，各种脱壳工具如下图所示：</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_DC5HB2MNH48RB28.png" alt="image-20220613162509955"></p><h3 id="2-Hook脱壳法"><a href="#2-Hook脱壳法" class="headerlink" title="2.Hook脱壳法"></a>2.Hook脱壳法</h3><p>我们前面知道了，只要函数中包含DexFile对象，我们就可以通过Hook技术拿到对象，然后取到begin和size，从而进行脱壳，市面上使用较多的无非是Xposed和frida，我平时使用frida较为方便，这里也用frida和大家演示：</p><p>首先我们使用GDA识别加壳程序</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_TU56BFRM8CJGT37.png" alt="image-20220613164418413"></p><p>很明显是进行了整体加壳，有没其他加壳暂时不知道，我们先进行脱壳</p><p>找到脱壳点</p><p>通过IDA打开<code>libart.so</code>，搜索DexFile，我们可以找到海量的脱壳点</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_TC423VFDNC9CRXV.png" alt="image-20220613164747966"></p><p>我们就随便找一个包含DexFile的脱壳函数，然后记录符号值</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_BWCY4SWHRTCQ283.png" alt="image-20220613164841377"></p><p>然后我们编写hook脚本</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_6V47P8SJQFRRV4M.png" alt="image-20220613172003659"></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">这里之所以获取<span class="hljs-keyword">begin</span>加上一个指针，是因为我们前面讲了dexfile含有一个虚函数地址，所以加上一个指针偏移<br></code></pre></td></tr></table></figure><p>然后启动frida_server</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_VGGG2SNEEHDHFY7.png" alt="image-20220613170608657"></p><p>附加进程进行dump，这里我们存在sdcard下面，所以需要提前赋予sdcard权限</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_TN977TFA84YVTZ9.png" alt="image-20220613172109177"></p><p>这里就脱壳成功</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_E7HWJDDJN5XDHQF.png" alt="image-20220613172222202"></p><p>然后我们打开相应的dex</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_DHAKWU3K8GSXESP.png" alt="image-20220613172222202"></p><p>此时说明我们整体脱壳成功，不过应用还有抽取壳，这个不是本文解决的内容</p><h3 id="3-插桩脱壳法"><a href="#3-插桩脱壳法" class="headerlink" title="3.插桩脱壳法"></a>3.插桩脱壳法</h3><p>插桩脱壳法，就是在Android源码里面定位到相应的脱壳点，然后插入相应的代码，重新编译源码生成系统镜像，最后就可以使用定制的系统进行脱壳</p><p>我们在<a href="https://bbs.pediy.com/thread-269575.htm">源码编译（1）——Android6.0源码编译详解</a>中已经讲述了如何编译源码，接下来我们进行插桩脱壳</p><p>同理、还是定位脱壳点，我们还是随便定位一个脱壳点LoadMethod 然后进行插桩</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_3SKERM5ZAKPEVFC.png" alt="image-20220613220518548"></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>add<span class="hljs-string">``</span>char dexfilepath[<span class="hljs-string">``</span><span class="hljs-number">100</span><span class="hljs-string">``</span>]<span class="hljs-string">``</span>=<span class="hljs-string">``</span><span class="hljs-number">0</span><span class="hljs-string">``</span>;<span class="hljs-string">``</span>memset(dexfilepath,<span class="hljs-string">``</span><span class="hljs-number">0</span><span class="hljs-string">``</span>,<span class="hljs-string">``</span><span class="hljs-number">100</span><span class="hljs-string">``</span>);<span class="hljs-string">``</span><span class="hljs-keyword">sprintf</span>(dexfilepath,<span class="hljs-string">``</span><span class="hljs-string">&quot;%d_%zu_LoadMethod.dex&quot;</span><span class="hljs-string">``</span>,getpid(),dex_file.Size());<span class="hljs-string">``</span><span class="hljs-keyword">int</span><span class="hljs-string">` `</span>dexfd <span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-keyword">open</span><span class="hljs-string">``</span>(dexfilepathm,O_CREAT|O_RDWR,<span class="hljs-string">``</span><span class="hljs-number">666</span><span class="hljs-string">``</span>);<span class="hljs-string">``</span><span class="hljs-keyword">if</span><span class="hljs-string">``</span>(dexfd&gt;<span class="hljs-string">``</span><span class="hljs-number">0</span><span class="hljs-string">``</span>)&#123;<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-keyword">int</span><span class="hljs-string">` `</span>result <span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-keyword">write</span>(dexfd,dex_file.Begin(),dex_file.Size());<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-keyword">if</span><span class="hljs-string">``</span>(result&gt;<span class="hljs-string">``</span><span class="hljs-number">0</span><span class="hljs-string">``</span>)&#123;<span class="hljs-string">``</span>    <span class="hljs-string">``</span><span class="hljs-keyword">close</span>(dexfd);<span class="hljs-string">``</span>    <span class="hljs-string">``</span>LOG(WARNING)&lt;&lt;<span class="hljs-string">``</span><span class="hljs-string">&quot;LoadMethod&quot;</span><span class="hljs-string">``</span>&lt;&lt;dexfilepath;<span class="hljs-string">``</span>  <span class="hljs-string">``</span>&#125;<span class="hljs-string">` `</span>&#125;<span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>add<br></code></pre></td></tr></table></figure><p>显示详细信息</p><p>同理我们在<code>execute</code>同样插桩此段代码，最后进行编译，编译成功</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_A9VEF93XZXNSNK8.png" alt="image-20220613172222202"></p><p>然后给程序授权sdcard权限，再次启动应用，就可以看见脱取的dex文件就保存在sdcard目录下</p><p><img src="https://bbs.pediy.com/97.png" alt="image-20220613215956911"></p><p>再次将sdcard下dex文件打开，这里我们已经看见了8732435这个文件，再次打开脱取成功</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_DHAKWU3K8GSXESP.png" alt="image-20220613172222202"></p><h3 id="4-反射脱壳法"><a href="#4-反射脱壳法" class="headerlink" title="4.反射脱壳法"></a>4.反射脱壳法</h3><p>反射脱壳法的核心思想就是利用前面我们提到的mCooike值</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs d">核心思路：反射 <span class="hljs-string">``</span>+<span class="hljs-string">` `</span>mCookie<span class="hljs-string">``</span>步骤：<span class="hljs-string">``</span><span class="hljs-number">1</span><span class="hljs-string">``</span>、找到加固apk的任一<span class="hljs-string">``c</span>lass<span class="hljs-string">``</span>，一般选择主Application或Activity<span class="hljs-string">``</span><span class="hljs-number">2</span><span class="hljs-string">``</span>、通过该类找到对应的Classloader<span class="hljs-string">``</span><span class="hljs-number">3</span><span class="hljs-string">``</span>、通过该Classloader找到BaseDexClassLoader<span class="hljs-string">``</span><span class="hljs-number">4</span><span class="hljs-string">``</span>、通过BaseDexClassLoader找到其字段DexPathList<span class="hljs-string">``</span><span class="hljs-number">5</span><span class="hljs-string">``</span>、通过DexPathList找到其变量Element数组dexElements<span class="hljs-string">``</span><span class="hljs-number">6</span><span class="hljs-string">``</span>、迭代该数组，该数组内部包含DexFile结构<span class="hljs-string">``</span><span class="hljs-number">7</span><span class="hljs-string">``</span>、通过DexFile获取其变量mCookie和mFileName<span class="hljs-string">` `</span>至此我们已经获取了mCookie<span class="hljs-string">` `</span>对该mCookie的解释:<span class="hljs-string">``</span>#<span class="hljs-number">1</span>、<span class="hljs-number">4.4</span>以下好像，mCookie对应的是一个<span class="hljs-keyword">int</span>值，该值是指向native层内存中的dexfile的指针<span class="hljs-string">``</span>#<span class="hljs-number">2</span>、<span class="hljs-number">5.0</span>是一个<span class="hljs-built_in">long</span>值，该值指向native层std::vector&lt;<span class="hljs-keyword">const</span> DexFile*&gt;* 指针，注意这里有多个dex，你需要找到你要的<span class="hljs-string">``</span>#<span class="hljs-number">3</span>、<span class="hljs-number">8.0</span>，该值也是一个<span class="hljs-built_in">long</span>型的值，指向底层vector，但是vector下标<span class="hljs-number">0</span>是oat文件，从<span class="hljs-number">1</span>开始是dex文件<span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">` `</span>至于你手机是那个版本，如果没有落入我上面描述的，你需要自己看看代码<span class="hljs-string">` `</span><span class="hljs-number">8</span><span class="hljs-string">``</span>、根据mCookie对应的值做转换，最终你能找到dexfile内存指针<span class="hljs-string">``</span><span class="hljs-number">9</span><span class="hljs-string">``</span>、把该指针转换为dexfile结构，通过findClassDef来匹配你所寻找的dex是你要的dex<span class="hljs-string">``</span><span class="hljs-number">10</span><span class="hljs-string">``</span>、dump写文件<br></code></pre></td></tr></table></figure><p>显示详细信息</p><p>综述mCookie是在native层就是dexfile的指针，我们利用反射原理来获取mCookie，从而就可以进行脱壳了，这里我们同样使用frida演示：</p><p>编写hook代码</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_AST7YFB8U7KAPUW.png" alt="image-20220613190231102"></p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_G9A6TCJ8RHYCJPB.png" alt="image-20220613190303491"></p><p>我们看见了和上面同样大小的8841876_mCookie.dex</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_DPU2G6VP2W8AGFT.png" alt="image-20220613190401266"></p><p>使用工具打开，发现同样脱壳成功</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_7NS398ERHB8V476.png" alt="image-20220613190438224"></p><h3 id="5-动态调试脱壳法"><a href="#5-动态调试脱壳法" class="headerlink" title="5.动态调试脱壳法"></a>5.动态调试脱壳法</h3><p>所谓动态调试法，核心原理和上面一样，就是我们在动态调试的过程中找到DexFile的起始地址和大小，然后执行脚本进行dump</p><p>首先选取脱壳点，我们还是选择<code>DexFile::DexFile</code></p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_VUKFUET2WH2G8HM.png" alt="image-20220613210130186"></p><p>动态调试的步骤我在前面的文章中已经做了详细的讲解，不会的朋友去看前面的文章</p><p>首先我们启动android_server</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_N4CAU6X29TQ5CMT.png" alt="image-20220613194111711"></p><p>然后我们附加上进程</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_A4VHQBKZNJFESXM.png" alt="image-20220613194326114"></p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_MJA6UTHVQM6M8RB.png" alt="image-20220613195349008"></p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_NK9UQCKAH22N9GY.png" alt="image-20220613203024990"></p><p>然后我们打开libart.so，并定位到DexFile::DexFile</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_88B2CXXK96K8YT6.png" alt="image-20220613210859021"></p><p>然后在该函数下断点，然后F9过来</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_RD7MFCWRA2TBWJG.png" alt="image-20220613211145356"></p><p>此处我们就可以很明显看到X1就是我们的起始地址，X4是我们的偏移值</p><p>编写脚本进行hook</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">static main(void)&#123;  <span class="hljs-string">``</span>  <span class="hljs-string">``</span>auto fp, <span class="hljs-keyword">begin</span>, <span class="hljs-keyword">end</span>, dexbyte;   <span class="hljs-string">``</span>  <span class="hljs-string">``</span>fp <span class="hljs-string">``</span>=<span class="hljs-string">` `</span>fopen(<span class="hljs-string">``</span><span class="hljs-string">&quot;d:\\dump.dex&quot;</span><span class="hljs-string">``</span>, <span class="hljs-string">``</span><span class="hljs-string">&quot;wb+&quot;</span><span class="hljs-string">``</span>);   <span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-keyword">begin</span> <span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-number">0x76FCD93020</span><span class="hljs-string">``</span>;  <span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-keyword">end</span> <span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-keyword">begin</span> <span class="hljs-string">``</span>+<span class="hljs-string">` `</span><span class="hljs-number">0x7EEC5600</span><span class="hljs-string">``</span>;<span class="hljs-string">``</span>  <span class="hljs-string">``</span><span class="hljs-keyword">for</span><span class="hljs-string">` `</span>( dexbyte <span class="hljs-string">``</span>=<span class="hljs-string">` `</span><span class="hljs-keyword">begin</span>; dexbyte&lt;<span class="hljs-keyword">end</span>;dexbyte<span class="hljs-string">``</span>+<span class="hljs-string">``</span>+<span class="hljs-string">``</span>)<span class="hljs-string">``</span>  <span class="hljs-string">``</span>&#123;<span class="hljs-string">``</span>  <span class="hljs-string">``</span>fputc(<span class="hljs-title class_">Byte</span>(dexbyte), fp);    <span class="hljs-string">``</span>  <span class="hljs-string">``</span>&#125; <span class="hljs-string">` `</span>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_YR5NB8X8376PY2D.png" alt="image-20220613214647627"></p><p>直接运行run</p><p>然后我们查看dump.dex文件</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_H6PK6RS65D67D7W.png" alt="image-20220613223330340"></p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_X8PM73N62QYQ5HK.png" alt="image-20220613215148251"></p><p>我们可以发现这里是代理类，还没有到我们想要的dex，我们再次F9，再次到这里，地址再次改变，再次结合长度来计算，我们每次计算可以取小点值，先试一下</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_PPQMMV4MPRTE24E.png" alt="image-20220613215343895"></p><p>发现还是不是，我们需要不停测试直到dump出dex为此</p><p>这里大家可以下去按照此方法尝试，或者换一个脱壳点来尝试</p><h3 id="6-特殊API脱壳法"><a href="#6-特殊API脱壳法" class="headerlink" title="6.特殊API脱壳法"></a>6.特殊API脱壳法</h3><p>所谓特殊的API脱壳法就是通过Android自身提供的API来获得Dex，这主要是参考Fdex2，前面我们讲了Fdex2主要是利用Android7.0及以下提供了getDex()和getBytes()两个API，我们可以直接可以获得class对象，然后直接调用这两个API</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_RP8TR8UMH3WVQZN.png" alt="image-20220613191047342"></p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_AD9VCKDKHNADVH3.png" alt="image-20220613191158377"></p><p>编写hook代码：</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_SVYRXHYJSQ5X8V5.png" alt="image-20220613192251923"></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-number">1.</span><span class="hljs-string">``</span>使用frida枚举所有Classloader<span class="hljs-string">``</span><span class="hljs-number">2.</span><span class="hljs-string">``</span>确定正确的ClassLoader并获取目标类的Class对象<span class="hljs-string">``</span><span class="hljs-number">3.</span><span class="hljs-string">``</span>通过Class对象获取得到dex对象<span class="hljs-string">``</span><span class="hljs-number">4.</span><span class="hljs-string">``</span>通过dex对象获取内存字节流并保存<br></code></pre></td></tr></table></figure><p>然后我们查看程序的类对象，随便dump一个类对象</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_J7X2KNVBH2YVPHQ.png" alt="image-20220613191722932"></p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_7UATJ4A4DV6QK5P.png" alt="image-20220613192447143"></p><p>然后我们再次用工具打开</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_BJ38Z6649X4TVTZ.png" alt="image-20220613192548342"></p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_QURQ9CN7SS48V8F.png" alt="image-20220613192659791"></p><p>发现就可以成功的dump</p><p>通过这种方式，我们发现神奇的事我们还可以抽取壳的情况，比如我们之前为空类</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_UFMR5YPKHZQZ5PR.png" alt="image-20220613192926853"></p><p>我们明显可以发现这里是采用了函数抽取的技术，一般的一代壳dump方案是无法解决抽取壳的，我们使用特殊API方法</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_8Z7P3YBWGTJTJ27.png" alt="image-20220613193028308"></p><p>再次打开，成功dump</p><p><img src="https://bbs.pediy.com/upload/attach/202206/905443_GUASR6BRXFUXTJ6.png" alt="image-20220613193102209"></p><p>这其实主要是抽取壳的一个回填时机的问题，这个详细放在以后抽取壳中讲解</p><h2 id="六、实验总结"><a href="#六、实验总结" class="headerlink" title="六、实验总结"></a>六、实验总结</h2><p>首先感谢寒冰大佬的FART技术文章，揭露了ART加壳的本质，整体加壳已经有很多大佬研究透彻，这里只是做个简单的总结。<br>本文总结了当下dex整体加壳的基本原理，和常用的一些脱壳方案，并一一进行复现，还有一些文件监控法等，由于我平时用的很少就没列举了，复现实验过程中由于涉及到不同的实验，所以我用了Android 6.0 Android 7.0 Android 8.0三台机器进行实验，所以大家可以注意下对应的方法和其Android版本，这里彻底解决了整体加壳的脱壳方案，到这里可以掌握脱壳、抓包、Hook、反Hook、反调、反签等基本手段，这样在进行Android App漏洞挖掘过程中将事半功倍。后面我将继续讲解Android App漏洞中的XSS漏洞、Sql注入漏洞、文件上传漏洞、端口扫描漏洞、WebView漏洞等。</p><p>脱壳脚本相关样本会放在github，所有的脱壳脚本和工具和上传知识星球</p><p>github：<a href="https://github.com/WindXaa">github</a></p><h2 id="七、参考文献"><a href="#七、参考文献" class="headerlink" title="七、参考文献"></a>七、参考文献</h2><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">https:<span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>bbs.pediy.com<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-keyword">thread</span><span class="hljs-string">``</span>-<span class="hljs-string">``</span><span class="hljs-number">252630.</span>htm<span class="hljs-string">``</span>#msg_header_h2_4<span class="hljs-string">``</span>https:<span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>bbs.pediy.com<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-keyword">thread</span><span class="hljs-string">``</span>-<span class="hljs-string">``</span><span class="hljs-number">254555.</span>htm<span class="hljs-string">``</span>#msg_header_h2_4<span class="hljs-string">``</span>https:<span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>www.anquanke.com<span class="hljs-string">``</span>/<span class="hljs-string">``</span>post<span class="hljs-string">``</span>/<span class="hljs-string">``</span>id<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-number">221905</span><span class="hljs-string">``</span>?display<span class="hljs-string">``</span>=<span class="hljs-string">``</span>mobile<span class="hljs-string">``</span>https:<span class="hljs-string">``</span>/<span class="hljs-string">``</span>/<span class="hljs-string">``</span>www.qj301.com<span class="hljs-string">``</span>/<span class="hljs-string">``</span>news<span class="hljs-string">``</span>/<span class="hljs-string">``</span><span class="hljs-number">317.</span>html<br></code></pre></td></tr></table></figure><p><a href="https://bbs.pediy.com/thread-273214.htm">2022 KCTF春季赛【最佳人气奖】火热评选中！快来投票吧～</a></p><p>最后于 1天前 被随风而行aa编辑 ，原因：</p>]]></content>
    
    
    <categories>
      
      <category>移动安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>移动安全</tag>
      
      <tag>HOOK</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
